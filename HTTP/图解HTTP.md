> 图解HTTP
> 著：［日］上野宣
> 2014年5月第一次印刷

# 目录

<!-- TOC -->

- [第一章 了解Web及网络基础](#第一章-了解web及网络基础)
  - [1.1 使用HTTP协议访问Web](#11-使用http协议访问web)
  - [1.2 HTTP的诞生](#12-http的诞生)
  - [1.3 网络基础TCP/IP](#13-网络基础tcpip)
  - [1.4 与HTTP关系密切的协议：IP、TCP和DNS](#14-与http关系密切的协议iptcp和dns)
  - [1.5 负责域名解析的DNS服务](#15-负责域名解析的dns服务)
  - [1.6 各种协议与HTTP协议的关系](#16-各种协议与http协议的关系)
  - [1.7 URI和URL](#17-uri和url)
- [第二章 简单的HTTP协议](#第二章-简单的http协议)
  - [2.1 HTTP协议用于客户端和服务器端之间的通信](#21-http协议用于客户端和服务器端之间的通信)
  - [2.2 通过请求和响应的交换达成通信](#22-通过请求和响应的交换达成通信)
  - [2.3 HTTP是不保存状态的协议](#23-http是不保存状态的协议)
  - [2.4 请求URI定位资源](#24-请求uri定位资源)
  - [2.5 告知服务器意图的HTTP方法](#25-告知服务器意图的http方法)
  - [2.6 使用方法下达命令](#26-使用方法下达命令)
  - [2.7 持久连接节省通信量](#27-持久连接节省通信量)
  - [2.8 使用Cookie的状态管理](#28-使用cookie的状态管理)
- [第三章 HTTP报文内的HTTP信息](#第三章-http报文内的http信息)
  - [3.1 HTTP报文](#31-http报文)
  - [3.2 请求报文及响应报文的结构](#32-请求报文及响应报文的结构)
  - [3.3 编码提升传输速率](#33-编码提升传输速率)
  - [3.4 发送多种数据的多部分对象集合](#34-发送多种数据的多部分对象集合)
  - [3.5 获取部分内容的范围请求](#35-获取部分内容的范围请求)
  - [3.6 内容协商返回最适合的内容](#36-内容协商返回最适合的内容)
- [第四章 返回结果的HTTP状态码](#第四章-返回结果的http状态码)
  - [4.1 状态码告知从服务器返回的请求结果](#41-状态码告知从服务器返回的请求结果)
  - [4.2 2XX成功](#42-2xx成功)
  - [4.3 3XX重定向](#43-3xx重定向)
  - [4.4 4XX客户端错误](#44-4xx客户端错误)
  - [4.5 5XX服务器错误](#45-5xx服务器错误)
- [第五章 与HTTP协作的Web服务器](#第五章-与http协作的web服务器)
  - [5.1 用单台虚拟主机实现多个域名](#51-用单台虚拟主机实现多个域名)
  - [5.2 通信数据转发程序：代理、网关、隧道](#52-通信数据转发程序代理网关隧道)
  - [5.3 保存资源的缓存](#53-保存资源的缓存)
- [第六章 HTTP首部](#第六章-http首部)
  - [6.1 HTTP报文首部](#61-http报文首部)
  - [6.2 HTTP首部字段](#62-http首部字段)
  - [6.3 HTTP/1.1通用首部字段](#63-http11通用首部字段)
  - [6.4 请求首部字段](#64-请求首部字段)
  - [6.5 响应首部字段](#65-响应首部字段)
  - [6.6 实体首部字段](#66-实体首部字段)
  - [6.7 为Cookie服务的首部字段](#67-为cookie服务的首部字段)
  - [6.8 其他首部字段](#68-其他首部字段)
- [第七章 确保Web安全的HTTPS](#第七章-确保web安全的https)
  - [7.1 HTTP的缺点](#71-http的缺点)
  - [7.2 HTTP+加密+认证+完整性保护=HTTPS](#72-http加密认证完整性保护https)
- [第八章 确认访问用户身份的认证](#第八章-确认访问用户身份的认证)
  - [8.1 何为认证](#81-何为认证)
  - [8.2 BASIC认证](#82-basic认证)
  - [8.3 DIGEST认证](#83-digest认证)
  - [8.4 SSL客户端认证](#84-ssl客户端认证)
  - [8.5 基于表单认证](#85-基于表单认证)
- [第九章 基于HTTP的功能追加协议](#第九章-基于http的功能追加协议)
  - [9.1 基于HTTP的协议](#91-基于http的协议)
  - [9.2 消除HTTP瓶颈的SPDY](#92-消除http瓶颈的spdy)
  - [9.3 使用浏览器进行全双工通信的WebSocket](#93-使用浏览器进行全双工通信的websocket)
  - [9.4 期盼已久的HTTP/2.0](#94-期盼已久的http20)
  - [9.5 Web服务器管理文件的WebDAV](#95-web服务器管理文件的webdav)
- [第十章 构建Web内容的技术](#第十章-构建web内容的技术)
  - [10.1 HTML](#101-html)
  - [10.2 动态HTML](#102-动态html)
  - [10.3 Web应用](#103-web应用)
  - [10.4 数据发布的格式及语言](#104-数据发布的格式及语言)
- [第十一章 Web的攻击技术](#第十一章-web的攻击技术)
  - [11.1 针对Web的攻击技术](#111-针对web的攻击技术)
  - [11.2 因输出值转义不完全引发的安全漏洞](#112-因输出值转义不完全引发的安全漏洞)
  - [11.3 因设置或设计上的缺陷引发的安全漏洞](#113-因设置或设计上的缺陷引发的安全漏洞)
  - [11.4 因会话管理疏忽引发的安全漏洞](#114-因会话管理疏忽引发的安全漏洞)
  - [11.5 其他安全漏洞](#115-其他安全漏洞)

<!-- /TOC -->

# 第一章 了解Web及网络基础

## 1.1 使用HTTP协议访问Web

Web 页面不能凭空显示出来。根据 Web 浏览器地址栏中指定的 URL， Web 浏览器从 Web 服务器端获取文件资源（resource）等信息，从而显示出 Web 页面。像这种通过发送请求获取服务器资源的 Web 浏览器等，都可称为客户端（client）。

Web 使用一种名为 HTTP（HyperText Transfer Protocol，超文本传输协议）的协议作为规范，完成从客户端到服务器端等一系列运作流程。而协议是指规则的约定。可以说， Web 是建立在 HTTP 协议上通信的。

## 1.2 HTTP的诞生

现在已提出了 3 项 WWW 构建技术，分别是：把 SGML 作为页面的文本标记语言的 HTML（HyperText Markup Language，超文本标记语言）；作为文档传递协议的 HTTP ；指定文档所在地址的 URL（Uniform Resource Locator，统一资源定位符）。

WWW 这一名称， 是 Web 浏览器当年用来浏览超文本的客户端应用程序时的名称。现在则用来表示这一系列的集合，也可简称为 Web。

## 1.3 网络基础TCP/IP

通常使用的网络（包括互联网）是在 TCP/IP 协议族的基础上运作的。而 HTTP 属于它内部的一个子集。

不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议（protocol）。协议中存在各式各样的内容。从电缆的规格到 IP 地址的选定方法、寻找异地用户的方法、双方建立通信的顺序，以及 Web 页面显示需要处理的步骤，等等。

像这样把与互联网相关联的协议集合起来总称为 TCP/IP。也有说法认为， TCP/IP 是指 TCP 和 IP 这两种协议。还有一种说法认为， TCP/IP 是在 IP 协议的通信过程中，使用到的协议族的统称。

TCP/IP 协议族里重要的一点就是分层。 TCP/IP 协议族按层次分别分为以下 4 层： 应用层、传输层、网络层和数据链路层。

- 应用层。应用层决定了向用户提供应用服务时通信的活动。
- 传输层。传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。
- 网络层（又名网络互联层）。网络层用来处理在网络上流动的数据包。
- 链路层（又名数据链路层，网络接口层）。用来处理连接网络的硬件部分。

利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往上走。

发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。 反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种把数据信息包装起来的做法称为封装（encapsulate）。

## 1.4 与HTTP关系密切的协议：IP、TCP和DNS

负责传输的 IP 协议。按层次分， IP（Internet Protocol）网际协议位于网络层。

IP 协议的作用是把各种数据包传送给对方。 而要保证确实传送到对方那里，则需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC 地址（Media Access Control Address）。IP 地址指明了节点被分配到的地址， MAC 地址是指网卡所属的固定地址。 IP 地址可以和 MAC 地址进行配对。 IP 地址可变换，但 MAC 地址基本上不会更改。

使用 ARP 协议凭借 MAC 地址进行通信。IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。 而在进行中转时，会利用下一站中转设备的 MAC 地址来搜索下一个中转目标。 这时，会采用 ARP 协议（Address Resolution Protocol）。 ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。

确保可靠性的 TCP 协议。按层次分， TCP 位于传输层，提供可靠的字节流服务。

所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指， 能够把数据准确可靠地传给对方。一言以蔽之，TCP 协议为了更容易传送大数据才把数据分割， 而且 TCP 协议能够确认数据最终是否送达到对方。

确保数据能到达目标。为了准确无误地将数据送达目标处， TCP 协议采用了三次握手（three-way handshaking）策略。用 TCP 协议把数据包送出去后， TCP 不会对传送后的情况置之不理， 它一定会向对方确认是否成功送达。握手过程中使用了 TCP 的标志（flag）——SYN（synchronize）和 ACK （acknowledgement）。

## 1.5 负责域名解析的DNS服务

DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。

计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。比如www.hackr.jp。用户通常使用主机名或域名来访问对方的计算机， 而不是直接通过IP 地址访问。 因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。

但要让计算机去理解名称， 相对而言就变得困难了。因为计算机更擅长处理一长串数字。为了解决上述的问题， DNS 服务应运而生。 DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址。

## 1.6 各种协议与HTTP协议的关系

客户端。

HTTP协议的职责。生成针对目标Web服务器的HTTP请求报文。

TCP协议的职责。为了方便通信，将HTTP请求报文分割成报文段。

路由器。

IP协议的职责。搜索对方的地址，一边中转一边传送。

服务器。

TCP协议的职责。从对方那里接收到的报文段

HTTP协议的职责。对Web服务器请求的内容的处理

## 1.7 URI和URL

统一资源标识符。URI 是 Uniform Resource Identifier 的缩写。 URI 就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。采用HTTP协议时，协议方案就是http。除此之外，还有ftp、mailto、telnet、file等。

- Uniform。规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。 另外，加入新增的协议方案（如 http: 或 ftp:）也更容易。

- Resource。资源的定义是“可标识的任何东西”。除了文档文件、图像或服务（例如当天的天气预报）等能够区别于其他类型的， 全都可作为资源。另外，资源不仅可以是单一的，也可以是多数的集合体。

- Identifier。表示可标识的对象。也称为标识符。

URI格式。表示指定的 URI，要使用涵盖全部必要信息的绝对 URI、绝对 URL 以及相对 URL。相对 URL，是指从浏览器中基本 URI 处指定的 URL，形如 /image/logo.gif。

使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。不区分字母大小写，最后附一个冒号（:）。也可使用 data: 或 javascript: 这类指定数据或脚本程序的方案名。

# 第二章 简单的HTTP协议

## 2.1 HTTP协议用于客户端和服务器端之间的通信 

HTTP 协议和 TCP/IP 协议族内的其他众多的协议相同，用于客户端和服务器之间的通信。请求访问文本或图像等资源的一端称为客户端， 而提供资源响应的一端称为服务器端。在两台计算机之间使用 HTTP 协议通信时，在一条通信线路上必定有一端是客户端，另一端则是服务器端。

## 2.2 通过请求和响应的交换达成通信

HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。

客户端发送给服务器端的请求报文内容如下。起始行开头的 GET 表示访问服务器的类型，称为方法
（method）。随后的字符串 /index.htm 指明了请求访问的资源对象，也叫做请求 URI（request-URI）。最后的 HTTP/1.1，即 HTTP 的版本号，用来提示客户端使用的 HTTP 协议功能。综合来看，这段请求内容的意思是：请求访问某台 HTTP 服务器上的 /index.htm 页面资源。

```
GET /index.htm HTTP/1.1
Host: hackr.jp
```

请求报文是由请求方法、 请求 URI、协议版本、可选的请求首部字段和内容实体构成的。

```
POST /form/entry HTTP/1.1

Host: hackr.jp
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 16

name=ueno&age=37
```

接收到请求的服务器，会将请求内容的处理结果以响应的形式返回。在起始行开头的 HTTP/1.1 表示服务器对应的 HTTP 版本。紧挨着的 200 OK 表示请求的处理结果的状态码（status code）和原因短语（reason-phrase）。下一行显示了创建响应的日期时间，是首部字段（header field）内的一个属性。接着以一空行分隔， 之后的内容称为资源实体的主体（entity body）。

```
HTTP/1.1 200 OK
Date: Tue, 10 Jul 2012 06:50:15 GMT
Content-Length: 362
Content-Type: text/html

<html>
……
```

响应报文基本上由协议版本、 状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、 可选的响应首部字段以及实体主体构成。稍后我们会对这些内容进行详细说明。

## 2.3 HTTP是不保存状态的协议

HTTP 是一种不保存状态，即无状态（stateless）协议。 HTTP 协议自身不对请求和响应之间的通信状态进行保存。 也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。

使用 HTTP 协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。 这是为了更快地处理大量事务，确保协议的可伸缩性，而特意把 HTTP 协议设计成如此简单的。

HTTP/1.1 虽然是无状态协议， 但为了实现期望的保持状态功能，于是引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。

## 2.4 请求URI定位资源

HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。当客户端请求访问资源而发送请求时， URI 需要将作为请求报文中的请求 URI 包含在内。指定请求 URI 的方式有很多。

除此之外，如果不是访问特定资源而是对服务器本身发起请求，可以用一个 * 来代替请求 URI。下面这个例子是查询 HTTP 服务器端支持的 HTTP 方法种类。

```
OPTIONS * HTTP/1.1
```

## 2.5 告知服务器意图的HTTP方法

GET：获取资源。GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。 也就是说，如果请求的资源是文本，那就保持原样返回； 如果是像 CGI（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。

POST：传输实体主体。POST 方法用来传输实体的主体。虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行传输，而是用 POST 方法。虽说 POST 的功能与 GET 很相似，但 POST 的主要目的并不是获取响应的主体内容。

PUT：传输文件。PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。

但是，鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法。若配合 Web 应用程序的验证机制，或架构设计采用 REST（REpresentational State Transfer，表征状态转移）标准的同类 Web 网站，就可能会开放使
用 PUT 方法。

HEAD：获得报文首部。HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。

DELETE：删除文件。DELETE 方法用来删除文件，是与 PUT 相反的方法。 DELETE 方法按请求 URI 删除指定的资源。

但是， HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机制，所以一般的 Web 网站也不使用 DELETE 方法。当配合 Web 应用程序的验证机制，或遵守 REST 标准时还是有可能会开放使用的。

OPTIONS：询问支持的方法。OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。

TRACE：追踪路径。TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。

CONNECT：要求用隧道协议连接代理。CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道
协议进行 TCP 通信。

## 2.6 使用方法下达命令

向请求 URI 指定的资源发送请求报文时，采用称为方法的命令。方法的作用在于， 可以指定请求的资源按期望产生某种行为。方法中有 GET、 POST 和 HEAD 等。

## 2.7 持久连接节省通信量

HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。

为解决上述 TCP 连接的问题， HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP 请求和响应能够更早地结束， 这样 Web 页面的显示速度也就相应提高了。

持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应， 才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求， 而不需要一个接一个地等待响应了。

## 2.8 使用Cookie的状态管理

Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。

Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息， 通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后， 会去检查究竟是从哪一个客户端发来的连接请求， 然后对比服务器上的记录，最后得到之前的状态信息。

# 第三章 HTTP报文内的HTTP信息

## 3.1 HTTP报文

用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的HTTP 报文叫做请求报文， 响应端（服务器端）的叫做响应报文。 HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。

HTTP 报文大致可分为报文首部和报文主体两块。 两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。

## 3.2 请求报文及响应报文的结构

请求报文的报文首部主要有请求行、请求首部字段、通用首部字段、实体首部字段和其他，响应报文的报文首部主要有状态行、响应首部字段、通用首部字段、实体首部字段和其他。总而言之，首部内容由以下数据组成。

- 请求行。包含用于请求的方法，请求 URI 和 HTTP 版本。
- 状态行。包含表明响应结果的状态码，原因短语和 HTTP 版本。
- 首部字段。包含表示请求和响应的各种条件和属性的各类首部。一般有 4 种首部，分别是：通用首部、请求首部、响应首部和实体首部。
- 其他。可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）

## 3.3 编码提升传输速率

HTTP 在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。 通过在传输时编码，能有效地处理大量的访问请求。 但是，编码的操作需要计算机来完成，因此会消耗更多的CPU 等资源。

报文主体和实体主体的差异。报文（message）是 HTTP 通信中的基本单位，由 8 位组字节流组成，通过 HTTP 通信传输。实体（entity）作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。
HTTP 报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。

向待发送邮件内增加附件时，为了使邮件容量变小，我们会先用ZIP 压缩文件之后再添加附件发送。 HTTP 协议中有一种被称为内容编码的功能也能进行类似的操作。内容编码指明应用在实体内容上的编码格式， 并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。

常用的内容编码有以下几种。

- gzip（GNU zip）
- compress（UNIX 系统的标准压缩）
- deflate（zlib）
- identity（不进行编码）

在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。 在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding）。

分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小， 而实体主体的最后一块会使用“0(CR+LF)”来标记。使用分块传输编码的实体主体会由接收的客户端负责解码， 恢复到编码前的实体主体。HTTP/1.1 中存在一种称为传输编码（Transfer Coding）的机制，它可以在通信时按某种编码方式传输，但只定义作用于分块传输编码中。

## 3.4 发送多种数据的多部分对象集合

发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了 MIME（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）机制， 它允许邮件处理文本、图片、视频等多个不同类型的数据。相应地， HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。

多部分对象集合包含的对象如下。

- multipart/form-data。在 Web 表单文件上传时使用。
- multipart/byteranges。状态码 206（Partial Content，部分内容）响应报文包含了多个范
围的内容时使用。

在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上Content-type。

## 3.5 获取部分内容的范围请求

网络下载需要一种可恢复的机制，所谓的恢复是指从之前下载中断处恢复下载。要实现该功能需要指定下载的实体范围。像这样，指定范围发送的请求叫做范围请求（Range Request）。对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求5001~10 000 字节内的资源。

执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。byte 范围的指定形式如下。

5001~10 000 字节

```
Range: bytes=5001-10000
```

从 5001 字节之后全部的

```
Range: bytes=5001-
```

从一开始到 3000 字节和 5000~7000 字节的多重范围

```
Range: bytes=-3000, 5000-7000
```

针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文。另外，对于多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文。如果服务器端无法响应范围请求， 则会返回状态码 200 OK 和完整的实体内容。

## 3.6 内容协商返回最适合的内容

同一个 Web 网站有可能存在着多份相同内容的页面。比如英语版和中文版的 Web 页面，它们内容上虽相同，但使用的语言却不同。当浏览器的默认语言为英语或中文， 访问相同 URI 的 Web 页面时，则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容协商（Content Negotiation）

内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。 内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。包含在请求报文中的某些首部字段（如下）就是判断的基准。

- Accept
- Accept-Charset
- Accept-Encoding
- Accept-Language
- Content-Language

内容协商技术有以下 3 种类型。
- 服务器驱动协商（Server-driven●Negotiation）由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理。但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容。
- 客户端驱动协商（Agent-driven●Negotiation）由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用 JavaScript 脚本在 Web 页面上自动进行上述选择。比如按 OS 的类型或浏览器类型，自行切换成 PC 版页面或手机版页面。
- 透明协商（Transparent●Negotiation）是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。

# 第四章 返回结果的HTTP状态码

## 4.1 状态码告知从服务器返回的请求结果

状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。

状态码如 200 OK，以 3 位数字和原因短语组成。数字中的第一位指定了响应类别， 后两位无分类。响应类别有以下 5 种。

状态码 类别 原因短语
1XX Informational（信息性状态码） 接收的请求正在处理
2XX Success（成功状态码） 请求正常处理完毕
3XX Redirection（重定向状态码） 需要进行附加操作以完成请求
4XX Client Error（客户端错误状态码） 服务器无法处理请求
5XX Server Error（服务器错误状态码） 服务器处理请求出错

## 4.2 2XX成功

2XX 的响应结果表明请求被正常处理了。

200 OK 表示从客户端发来的请求在服务器端被正常处理了。在响应报文内， 随状态码一起返回的信息会因方法的不同而发生改变。比如，使用 GET 方法时，对应请求资源的实体会作为响应返回；而使用 HEAD 方法时，对应请求资源的实体首部不随报文主体作为响应返回（即在响应中只返回首部，不会返回实体的主体部分）。

204 No Content。该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。 另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后， 返回 204 响应，那么浏览器显示的页面不发生更新。一般在只需要从客户端往服务器发送信息， 而对客户端不需要发送新信息内容的情况下使用。

206 Partial Content。该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。

## 4.3 3XX重定向

3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。

301 Moved Permanently。永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。像下方给出的请求 URI，当指定资源路径的最后忘记添加斜杠“/”，就会产生 301 状态码。

302 Found。临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动， 只是临时性质的。换句话说，已移动的资源对应的URI 将来还有可能发生改变。比如，用户把 URI 保存成书签， 但不会像301 状态码出现时那样去更新书签， 而是仍旧保留返回 302 状态码的页
面对应的 URI。

303 See Other。该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。

304 Not Modified。该状态码表示客户端发送附带条件的请求 A 时，服务器端允许请求访问资源，但未满足条件的情况。 304 状态码返回时，不包含任何响应的主体部分。 304 虽然被划分在 3XX 类别中，但是和重定向没有关系。

307 Temporary Redirect。临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。307 会遵照浏览器标准， 不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。

## 4.4 4XX客户端错误

4XX 的响应结果表明客户端是发生错误的原因所在。

400 Bad Request。该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。

401 Unauthorized。该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。 另外若之前已进行过 1 次请求，则表示用户认证失败。返回含有 401 的响应必须包含一个适用于被请求资源的 WWWAuthenticate 首部用以质询（challenge）用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。

403 Forbidden。该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由， 但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。未获得文件系统的访问授权， 访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。

404 Not Found。该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。

## 4.5 5XX服务器错误

5XX 的响应结果表明服务器本身发生错误。

500 Internal Server Error。该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web
应用存在的 bug 或某些临时的故障。

503 Service Unavailable。该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无
法处理请求。 如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。

状态码和状况的不一致。不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。比
如 Web 应用程序内部发生错误，状态码依然返回 200 OK，这种情况也经常遇到。

# 第五章 与HTTP协作的Web服务器

## 5.1 用单台虚拟主机实现多个域名

HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。比如，提供 Web 托管服务（Web Hosting Service）的供应商，可以用一台服务器为多位客户服务，也可以以每位客户持有的域名运行各自不同的网站。这是因为利用了虚拟主机（Virtual Host，又称虚拟服务器）的功能。即使物理层面只有一台服务器， 但只要使用虚拟主机的功能，则可以假想已具有多台服务器。

在互联网上， 域名通过 DNS 服务映射到 IP 地址（域名解析）之后访问目标网站。 可见，当请求发送到服务器时，已经是以 IP 地址形式访问了。所以，如果一台服务器内托管了 www.tricorder.jp 和 www.hackr.jp 这两个域名，当收到请求时就需要弄清楚究竟要访问哪个域名。

在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI。

## 5.2 通信数据转发程序：代理、网关、隧道

HTTP 通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道。它们可以配合服务器工作。这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端。

- 代理。代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色， 接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。
- 网关。网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。
- 隧道。隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。

代理。代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求 URI，会直接发送给前方持有资源的目标服务器。持有资源实体的服务器被称为源服务器。从源服务器返回的响应经过代理服务器后再传给客户端。在 HTTP 通信过程中，可级联多台代理服务器。请求和响应的转发会经过数台类似锁链一样连接起来的代理服务器。 转发时，需要附加Via 首部字段以标记出经过的主机信息。

通过设置组织内部的代理服务器可做到针对特定URI访问的控制。

使用代理服务器的理由有：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。

代理有多种使用方法， 按两种基准分类。一种是是否使用缓存，另一种是是否会修改报文。

- 缓存代理。代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时， 就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。
- 透明代理。转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。

网关。网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非 HTTP 协议服务。利用网关能提高通信的安全性， 因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。 比如，网关可以连接数据库，使用SQL 语句查询数据。 另外，在 Web 购物网站上进行信用卡结算时，网
关可以和信用卡结算系统联动。

利用网关可以由 HTTP 请求转化为其他协议通信。

隧道。隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等加密手段进行通信。 隧道的目的是确保客户端能与服务器进行安全的通信。隧道本身不会去解析 HTTP 请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。

通过隧道的传输，可以和远距离的服务器安全通信。隧道本身是透明的，客户端不用在意隧道的存在。

## 5.3 保存资源的缓存

缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。缓存服务器是代理服务器的一种， 并归类在缓存代理类型中。换句话说，当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本。

缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源， 而源服务器也不必多次处理相同的请求了。

缓存的有效期限。当遇上源服务器上的资源更新时， 如果还是使用不变的缓存，那就会演变成返回更新前的“旧”资源了。即使存在缓存， 也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。 若判断缓存失效，缓存服务器将会再次从源服务器上获取“新”资源。

客户端的缓存。缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。以Internet Explorer 程序为例，把客户端缓存称为临时网络文件（Temporary Internet File）。浏览器缓存如果有效， 就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取。另外，和缓存服务器相同的一点是，当判定缓存过期后，会向源服务器确认资源的有效性。 若判断浏览器缓存失效，浏览器会再次请求新资源。

# 第六章 HTTP首部

## 6.1 HTTP报文首部

HTTP 协议的请求和响应报文中必定包含 HTTP 首部。首部内容为客户端和服务器分别处理请求和响应提供所需要的信息。 对于客户端用户来说，这些信息中的大部分内容都无须亲自查看。

报文首部由几个字段构成。空行 （CR＋LF）、报文主体共同构成报文。下面是两种报文的报文首部内容。

- HTTP 请求报文。在请求中， HTTP 报文由方法、 URI、 HTTP 版本、 HTTP 首部字段等部分构成。

- HTTP 响应报文。在响应中， HTTP 报文由 HTTP 版本、状态码（数字和原因短语）、HTTP 首部字段 3 部分构成。

在报文众多的字段当中， HTTP 首部字段包含的信息最为丰富。首部字段同时存在于请求和响应报文内，并涵盖 HTTP 报文相关的内容信息。

## 6.2 HTTP首部字段

HTTP 首部字段传递重要信息。HTTP 首部字段是构成 HTTP 报文的要素之一。在客户端与服务器之间以 HTTP 协议进行通信的过程中，无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。

HTTP 首部字段结构。HTTP 首部字段是由首部字段名和字段值构成的，中间用冒号“:”分割。另外，字段值对应单个 HTTP 首部字段可以有多个值。

```
Content-Type: text/html

Keep-Alive: timeout=15, max=100
```

若 HTTP 首部字段重复了会如何。当 HTTP 报文首部中出现了两个或两个以上具有相同首部字段名时会
怎么样？这种情况在规范内尚未明确，根据浏览器内部处理逻辑的不同，结果可能并不一致。有些浏览器会优先处理第一次出现的首部字段，而有些则会优先处理最后出现的首部字段。

HTTP 首部字段根据实际用途被分为以下 4 种类型。

- 通用首部字段（General Header Fields）。请求报文和响应报文两方都会使用的首部。

- 请求首部字段（Request Header Fields）。从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。

- 响应首部字段（Response Header Fields）。从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。

- 实体首部字段（Entity Header Fields）。针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。

 HTTP 协议通信交互中使用到的首部字段，不限于 RFC2616 中定义的 47 种首部字段。还有 Cookie、 Set-Cookie 和 Content-Disposition 等在其他 RFC 中定义的首部字段，它们的使用频率也很高。这些非正式的首部字段统一归纳在 RFC4229 HTTP Header Field Registrations 中。

HTTP 首部字段将定义成缓存代理和非缓存代理的行为，分成 2 种类型。
- 端到端首部（End-to-end Header）。分在此类别中的首部会转发给请求 / 响应对应的最终接收目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。
- 逐跳首部（Hop-by-hop Header）。分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。 HTTP/1.1 和之后版本中，如果要使用 hop-by-hop 首部，需提供 Connection 首部字段。

## 6.3 HTTP/1.1通用首部字段

通过指定首部字段 Cache-Control 的指令，就能操作缓存的工作机制。指令的参数是可选的，多个指令之间通过“,”分隔。首部字段 Cache-Control 的指令可用于请求及响应时。

```
Cache-Control: private, max-age=0, no-cache
```

Connection 首部字段具备如下两个作用。控制不再转发给代理的首部字段、管理持久连接。

在客户端发送请求和服务器返回响应内，使用 Connection 首部字段，可控制不再转发给代理的首部字段（即 Hop-by-hop 首部）。

HTTP/1.1版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定Connection首部字段的值为Close。

HTTP/1.1 之前的 HTTP 版本的默认连接都是非持久连接。为此，如果想在旧版本的 HTTP 协议上维持持续连接，则需要指定 Connection 首部字段的值为 Keep-Alive。

```
Connection:  不再转发的首部字段名
```

```
Connection: close
```

```
Connection: Keep-Alive
```

首部字段 Date 表明创建 HTTP 报文的日期和时间。如下，分别是HTTP/1.1 协议使用在 RFC1123 中规定的日期时间的格式；之前的 HTTP 协议版本中使用在 RFC850 中定义的格式；还有一种格式与 C 标准库内的 asctime() 函数的输出格式一致。

```
Date: Tue, 03 Jul 2012 04:40:59 GMT
```

```
Date: Tue, 03-Jul-12 04:40:59 GMT
```

```
Date: Tue Jul 03 04:40:59 2012
```

Pragma 是 HTTP/1.1 之前版本的历史遗留字段，仅作为与 HTTP/1.0 的向后兼容而定义。规范定义的形式唯一。该首部字段属于通用首部字段，但只用在客户端发送的请求中。客户端会要求所有的中间服务器不返回缓存的资源。

首部字段 Trailer 会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在 HTTP/1.1 版本分块传输编码时。

首部字段 Transfer-Encoding 规定了传输报文主体时采用的编码方式。HTTP/1.1 的传输编码方式仅对分块传输编码有效。

首部字段 Upgrade 用于检测 HTTP 协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。

使用首部字段 Via 是为了追踪客户端与服务器之间的请求和响应报文的传输路径。报文经过代理或网关时， 会先在首部字段 Via 中附加该服务器的信息，然后再进行转发。 这个做法和 traceroute 及电子邮件的 Received 首部的工作机制很类似。

HTTP/1.1 的 Warning 首部是从 HTTP/1.0 的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。

## 6.4 请求首部字段

请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、 客户端信息、对响应内容相关的优先级等内容。

Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。 可使用 type/subtype 这种形式，一次指定多种媒体类型。

- 文本文件
text/html, text/plain, text/css ...
application/xhtml+xml, application/xml ...

- 图片文件
image/jpeg, image/gif, image/png ...

- 视频文件
video/mpeg, video/quicktime ...

- 应用程序使用的二进制文件
application/octet-stream, application/zip ...

若想要给显示的媒体类型增加优先级，则使用 q= 来额外表示权重值 A，用分号（;）进行分隔。权重值 q 的范围是 0~1（可精确到小数点后 3 位），且 1 为最大值。不指定权重 q 值时，默认权重为 q=1.0。当服务器提供多种内容时，将会首先返回权重值最高的媒体类型。

Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。 另外，可一次性指定多种字符集。与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。该首部字段应用于内容协商机制的服务器驱动协商。

Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。

首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。和 Accept 首部字段一样，按权重值 q 来表示相对优先级。

```
Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3
```

首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。

客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码 417 Expectation Failed。

首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址。 通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式。 使用代理时，应尽可能包含 From 首部字段（但可能会因代理不同，将电子邮件地址记录在 User-Agent 首部字段内）。

首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。 Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段。首部字段 Host 和以单台服务器分配多个域名的虚拟主机的工作机制有很密切的关联，这是首部字段 Host 必须存在的意义。

形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。

首部字段 If-Modified-Since，属附带条件之一，它会告知服务器若If-Modified-Since 字段值早于资源的更新时间， 则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。

首部字段 If-None-Match 属于附带条件之一。它和首部字段 IfMatch 作用相反。 用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求。

首部字段 If-Range 属于附带条件之一。它告知服务器若指定的If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。

首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。

通过TRACE方法或OPTIONS方法，发送包含首部字段 MaxForwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards的值减1后重新赋值。当服务器接收到 Max-Forwards 值为0的请求时，则不再进行转发，而是直接返回响应。

接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息。这个行为是与客户端和服务器之间的 HTTP 访问认证相类似的，不
同之处在于， 认证行为发生在客户端与代理之间。客户端与服务器之间的认证，使用首部字段 Authorization 可起到相同作用。

对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返回状态码 200 OK 的响应及全部资源。

首部字段 Referer 会告知服务器请求的原始资源的 URI。客户端一般都会发送 Referer 首部字段给服务器。但当直接在浏览器的地址栏输入 URI，或出于安全性的考虑时，也可以不发送该首部字段。

首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。 它和首部字段  Accept-Encoding 的功能很相像，但是用于传输编码。首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。

首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。由网络爬虫发起请求时， 有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。

## 6.5 响应首部字段

响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。

首部字段 Accept-Ranges 是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。

首部字段 Age 能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。

首部字段 ETag 能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。

使用首部字段 Location 可以将响应接收方引导至某个与请求 URI 位置不同的资源。

首部字段 Proxy-Authenticate 会把由代理服务器所要求的认证信息发送给客户端。

首部字段 Retry-After 告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用。

首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。 不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。

首部字段 WWW-Authenticate 用于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中，肯定带有首部字段 WWW-Authenticate。

## 6.6 实体首部字段

实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。

首部字段 Allow 用于通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回。

首部字段 Content-Encoding 会告知客户端服务器对实体的主体部分选用的内容编码方式。 内容编码是指在不丢失实体信息的前提下所进行的压缩。

首部字段 Content-Language 会告知客户端，实体主体使用的自然语言（指中文或英文等语言）。

首部字段 Content-Length 表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时， 不能再使用 Content-Length 首部字段。

首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同， Content-Location 表示的是报文主体返回资源对应的 URI。

首部字段 Content-MD5 是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。

针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。 字段值以字节为单位，表示当前发送部分及整个实体大小。

首部字段 Content-Type 说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值。

首部字段 Expires 会将资源失效的日期告知客户端。缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在Expires 字段值指定的时间之前，响应的副本会一直被保存。当超过
指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。

首部字段 Last-Modified 指明资源最终修改的时间。一般来说，这个值就是 Request-URI 指定资源被修改的时间。但类似使用 CGI 脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间。

## 6.7 为Cookie服务的首部字段

Cookie 的工作机制是用户识别及状态管理。Web 网站为了管理用户的状态会通过 Web 浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该 Web 网站时，可通过通信方式拉回之前发放的 Cookie。调用 Cookie 时， 由于可校验 Cookie 的有效期，以及发送方的域、路径、协议等信息，所以正规发布的 Cookie 内的数据不会因来自其他Web 站点和攻击者的攻击而泄露。

首部字段名 | 说明 | 首部类型
--- | --- | ----
Set-Cookie | 开始状态管理所使用的Cookie信息 | 响应首部字段
Cookie | 服务器接收到的Cookie信息 | 请求首部字段

当服务器准备开始管理客户端的状态时，会事先告知各种信息。

```
Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; ⇒
path=/; domain=.hackr.jp; 
```

首部字段 Cookie 会告知服务器，当客户端想获得 HTTP 状态管理支持时，就会在请求中包含从服务器接收到的 Cookie。接收到多个Cookie 时，同样可以以多个 Cookie 形式发送。

```
Cookie: status=enable
```

## 6.8 其他首部字段

HTTP 首部字段是可以自行扩展的，所以在 Web 服务器和浏览器的应用上，会出现各种非标准的首部字段。

- X-Frame-Options
- X-XSS-Protection
- DNT
- P3P

首部字段 X-Frame-Options 属于 HTTP 响应首部，用于控制网站内容在其他 Web 网站的 Frame 标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。

首部字段 X-XSS-Protection 属于 HTTP 响应首部，它是针对跨站脚本攻击（XSS）的一种对策，用于控制浏览器 XSS 防护机制的开关。

首部字段 DNT 属于 HTTP 请求首部，其中 DNT 是 Do Not Track 的简称，意为拒绝个人信息被收集，是表示拒绝被精准广告追踪的一种方法。

首部字段 P3P 属于 HTTP 相应首部，通过利用 P3P（The Platform for Privacy Preferences，在线隐私偏好平台）技术，可以让 Web 网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。

# 第七章 确保Web安全的HTTPS

## 7.1 HTTP的缺点

HTTP 具有相当优秀和方便的以免，但是也有一些不足，例如。

- 通信使用明文（不加密），内容可能会被窃听
- 不验证通信方的身份，因此有可能遭遇伪装
- 无法证明报文的完整性，所以有可能已遭篡改

通信使用明文可能会被窃听。由于 HTTP 本身不具备加密的功能，所以也无法做到对通信整体（使用 HTTP 协议通信的请求和响应的内容）进行加密。即，HTTP 报文使用明文（指未经过加密的报文）方式发送。

TCP/IP 是可能被窃听的网络。按 TCP/IP 协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窃视。窃听相同段上的通信并非难事，只需要收集在互联网上流动的数据包（帧）就行了。对于收集来的数据包的解析工作，可交给那些抓包（Packet Capture）或嗅探器（Sniffer）工具。

加密处理防止被窃听。一种方式就是将通信加密。HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容。还有一种将参与通信的内容本身加密的方式。由于 HTTP 协议中没有加密机制， 那么就对 HTTP 协议传输的内容本身加密。即把 HTTP 报文里所含的内容进行加密处理。

不验证通信方的身份就可能遭遇伪装。HTTP 协议中的请求和响应不会对通信方进行确认。也就是说存在“服务器是否就是发送请求中 URI 真正指定的主机，返回的响应是否真的返回到实际提出请求的客户端”等类似问题。

任何人都可发起请求。在 HTTP 协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。 另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的 IP 地址和端口号没有被 Web 服务器设定限制访问的前提下）。

查明对手的证书。虽然使用 HTTP 协议无法确定通信方，但如果使用 SSL 则可以。SSL 不仅提供加密处理， 而且还使用了一种被称为证书的手段，可用于确定方。

无法证明报文完整性，可能已遭篡改。所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。

接收到的内容可能有误。由于 HTTP 协议无法证明通信的报文完整性，因此，在请求或响应送出之后知道对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。换句话说，没有任何办法确认，发出的请求/响应和接收到的请求/响应式前后相同的。请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle attack， MITM）。

如何防止篡改。虽然有使用 HTTP 协议确定报文完整性的方法，但事实上并不便捷、可靠。其中常用的是 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法。可惜的是，用这些方法也依然无法百分百保证确认结果正确。因为PGP 和 MD5 本身被改写的话，用户是没有办法意识到的。

为了有效防止这些弊端， 有必要使用 HTTPS。 SSL 提供认证和加密处理及摘要功能。 仅靠 HTTP 确保完整性是非常困难的，因此通过和其他协议组合使用来实现这个目标。下节我们介绍 HTTPS 的相关内容。

## 7.2 HTTP+加密+认证+完整性保护=HTTPS

HTTP 加上加密处理和认证以及完整性保护后即是 HTTPS。

经常会在 Web 的登录页面和购物结算界面等使用 HTTPS 通信。使用 HTTPS 通信时，不再用 http://，而是改用 https://。另外，当浏览器访问 HTTPS 通信有效的 Web 网站时，浏览器的地址栏内会出现一个带锁的标记。对 HTTPS 的显示方式会因浏览器的不同而有所改变。

HTTPS 是身披 SSL 外壳的 HTTP。

HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。在采用 SSL 后， HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。SSL 是独立于 HTTP 的协议，所以不光是 HTTP 协议，其他运行在
应用层的 SMTP 和 Telnet 等协议均可配合 SSL 协议使用。可以说 SSL 是当今世界上应用最为广泛的网络安全技术。

相互交换密钥的公开密钥加密技术。SSL 采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。近代的加密方法中加密算法是公开的， 而密钥却是保密的。通过这种方式得以保持加密方法的安全性。加密和解密都会用到密钥。 没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。 如果密钥被攻击者获得，那加密也就失去了意义。

共享密钥加密的困境。加密和解密同用一个密钥的方式称为共享密钥加密（Common key crypto system），也被叫做对称密钥加密。以共享密钥方式加密时必须将密钥也发给对方。可究竟怎样才能安
全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落入攻击者之手， 同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。

使用两把密钥的公开密钥加密。公开密钥加密方式很好地解决了共享密钥加密的困难。公开密钥加密使用一对非对称的密钥。 一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。使用公开密钥加密方式， 发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。 利用这种方式， 不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。

HTTPS采用混合加密机制。HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换， 那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。所以应充分利用两者各自的优势， 将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式， 之后的建立通信交换报文阶段则使用共享密钥加密方式。

证明公开密钥正确性的证书。使用由数字证书认证机构（CA， Certificate Authority）和其相关机关颁发的公开密钥证书。数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。接到证书的客户端可使用数字证书认证机构的公开密钥， 对那张证书上的数字签名进行验证， 一旦验证通过，客户端便可明确两件事：一，认证服务器的公开密钥的是真实有效的数字证书认证机构。 二，服务器的公开密钥是值得信赖的。

可证明组织真实性的EV SSL证书。证书的一个作用是用来证明作为通信一方的服务器是否规范，另外一个作用是可确认对方服务器背后运营的企业是否真实存在。 拥有该特性的证书就是 EV SSL 证书（Extended Validation SSL Certificate）。

用以确认客户端的客户端证书。HTTPS 中还可以使用客户端证书。以客户端证书进行客户端认证，证明服务器正在通信的对方始终是预料之内的客户端， 其作用跟服务器证书如出一辙。

# 第八章 确认访问用户身份的认证

## 8.1 何为认证

计算机本身无法判断坐在显示器前的使用者的身份。进一步说，也无法确认网络的那头究竟有谁。可见，为了弄清楚究竟是谁在访问服务器，就得让对方的客户端自报家门。核对的信息通常是指以下这些。
- 密码：只有本人才会知道的字符串信息。 
- 动态令牌：仅限本人持有的设备内显示的一次性密码。 
- 数字证书：仅限本人（终端）持有的信息。 
- 生物认证：指纹和虹膜等本人的生理信息。 
- IC 卡等：仅限本人持有的信息。

HTTP/1.1 使用的认证方式如下所示。
- BASIC 认证（基本认证）
- DIGEST 认证（摘要认证）
- SSL 客户端认证
- FormBase 认证（基于表单认证）

## 8.2 BASIC认证

BASIC 认证（基本认证）是从 HTTP/1.0 就定义的认证方式。即便是现在仍有一部分的网站会使用这种认证方式。 是 Web 服务器与通信客户端之间进行的认证方式。BASIC 认证虽然采用 Base64 编码方式，但这不是加密处理。不需要任何附加信息即可对其解码。 换言之，由于明文解码后就是用户 ID
和密码，在 HTTP 等非加密通信的线路上进行 BASIC 认证的过程中，如果被人窃听，被盗的可能性极高。

## 8.3 DIGEST认证

为弥补 BASIC 认证存在的弱点，从 HTTP/1.1 起就有了 DIGEST 认证。 DIGEST 认证同样使用质询 / 响应的方式（challenge/response），但不会像 BASIC 认证那样直接发送明文密码。所谓质询响应方式是指， 一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码。 最后将响应码返回给对方进行认证的方式。

## 8.4 SSL客户端认证

从使用用户 ID 和密码的认证方式方面来讲，只要二者的内容正确，即可认证是本人的行为。但如果用户 ID 和密码被盗，就很有可能被第三者冒充。利用 SSL 客户端认证则可以避免该情况的发生。SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书（在 HTTPS 一章已讲解）认证，服务器可确认访问是否来自已登录的客户端。

## 8.5 基于表单认证

基于表单的认证方法并不是在 HTTP 协议中定义的。客户端会向服务器上的 Web 应用程序发送登录信息（Credential），按登录信息的验证结果认证。多数情况下，输入已事先登录的用户 ID（通常是任意字符串或邮件地址）和密码等登录信息后， 发送给 Web 应用程序，基于认证结果来决定认证是否成功。

# 第九章 基于HTTP的功能追加协议

## 9.1 基于HTTP的协议

在建立 HTTP 标准规范时，制订者主要想把 HTTP 当作传输 HTML文档的协议。 随着时代的发展， Web 的用途更具多样性，比如演化成在线购物网站、 SNS（Social Networking Service，社交网络服务）、企业或组织内部的各种管理工具，等等。HTTP 功能上的不足可通过创建一套全新的协议来弥补。 可是目前基于 HTTP 的 Web 浏览器的使用环境已遍布全球，因此无法完全抛弃HTTP。有一些新协议的规则是基于 HTTP 的， 并在此基础上添加了新的功能。

## 9.2 消除HTTP瓶颈的SPDY

使用 HTTP 协议探知服务器上是否有内容更新，就必须频繁地从客户端到服务器端进行确认。 如果服务器上没有内容更新，那么就会产生徒劳的通信。若想在现有 Web 实现所需的功能，以下这些 HTTP 标准就会成为瓶颈。

- 一条连接上只可发送一个请求。 
- 请求只能从客户端开始。客户端不可以接收除响应以外的指令。 
- 请求 / 响应首部未经压缩就发送。首部信息越多延迟越大。 
- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多。 
- 可任意选择数据压缩格式。非强制压缩发送。

Ajax 的解决方法。Ajax（Asynchronous JavaScript and XML，异步 JavaScript 与 XML
技术）是一种有效利用 JavaScript 和 DOM（Document Object Model，文档对象模型）的操作， 以达到局部 Web 页面替换加载的异步通信手段。和以前的同步通信相比， 由于它只更新一部分页面，响应中传输的数据量会因此而减少，这一优点显而易见。

Comet 的解决方法。一旦服务器端有内容更新了， Comet 不会让请求等待，而是直接给客户端返回响应。这是一种通过延迟应答，模拟实现服务器端向客户端推送（Server Push）的功能。

陆续出现的 Ajax 和 Comet 等提高易用性的技术，一定程度上使HTTP 得到了改善， 但 HTTP 协议本身的限制也令人有些束手无策。为了进行根本性的改善，需要有一些协议层面上的改动。处于持续开发状态中的 SPDY 协议，正是为了在协议级别消除HTTP 所遭遇的瓶颈。

SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作。 同时，考虑到安全性问题， SPDY 规定通信中使用 SSL。SPDY 以会话层的形式加入， 控制对数据的流动，但还是采用HTTP 建立通信连接。 因此，可照常使用 HTTP 的 GET 和 POST 等方法、 cookie 以及 HTTP 报文等。使用 SPDY 后， HTTP 协议额外获得以下功能。

- 多路复用流
- 赋予请求优先级
- 压缩 HTTP 首部
- 推送功能
- 服务器提示功能

## 9.3 使用浏览器进行全双工通信的WebSocket

一旦 Web 服务器与客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个专用协议进行。 通信过程中可互相发送JSON、 XML、 HTML 或图片等任意格式的数据。由于是建立在 HTTP 基础上的协议，因此连接的发起方仍是客户端，而一旦确立 WebSocket 通信连接，不论服务器还是客户端，任意一方都可直接向对方发送报文。

列举一下 WebSocket 协议的主要特点
- 推送功能。支持由服务器向客户端推送数据的推送功能。这样，服务器可直接发送数据，而不必等待客户端的请求。
- 减少通信量。只要建立起 WebSocket 连接，就希望一直保持连接状态。和 HTTP 相比，不但每次连接时的总开销减少，而且由于 WebSocket 的首部信息很小，通信量也相应减少了。

## 9.4 期盼已久的HTTP/2.0

HTTP/2.0 的特点。HTTP/2.0 的目标是改善用户在使用 Web 时的速度体验。由于基本上都会先通过 HTTP/1.1 与 TCP 连接。探讨一下它们的实现方法。
- SPDY
- HTTP Speed ＋ Mobility
- Network-Friendly HTTP Upgrade

## 9.5 Web服务器管理文件的WebDAV

WebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）是一个可对 Web 服务器上的内容直接进行文件复制、 编辑等操作的分布式文件系统。它作为扩展 HTTP/1.1的协议定义在 RFC4918。除了创建、删除文件等基本功能，它还具备文件创建者管理、文件编辑过程中禁止其他用户内容覆盖的加锁功能， 以及对文件内容修改的版本控制功能。

# 第十章 构建Web内容的技术

## 10.1 HTML

HTML（HyperText Markup Language，超文本标记语言）是为了发送 Web 上的超文本（Hypertext）而开发的标记语言。超文本是一种文档系统，可将文档中任意位置的信息与其他信息（文本或图片等）建立关联，即超链接文本。标记语言是指通过在文档的某部分穿插特别的字符串标签，用来修饰文档的语言。我们把出现在 HTML 文档内的这种特殊字符串叫做 HTML 标签（Tag）。

CSS（Cascading Style Sheets，层叠样式表）可以指定如何展现HTML 内的各种元素， 属于样式表标准之一。即使是相同的 HTML 文档，通过改变应用的 CSS，用浏览器看到的页面外观也会随之改变。CSS 的理念就是让文档的结构和设计分离，达到解耦的目的。

## 10.2 动态HTML

所谓动态 HTML（Dynamic HTML），是指使用客户端脚本语言将静态的 HTML 内容变成动态的技术的总称。鼠标单击点开的新闻、Google Maps 等可滚动的地图就用到了动态 HTML。动态 HTML 技术是通过调用客户端脚本语言 JavaScript，实现对HTML 的 Web 页面的动态改造。利用 DOM（Document Object Model，文档对象模型）可指定欲发生动态变化的 HTML 元素。

## 10.3 Web应用

Web 应用是指通过 Web 功能提供的应用程序。比如购物网站、网上银行、 SNS、 BBS、搜索引擎和 e-learning 等。 互联网（Internet）或企业内网（Intranet）上遍布各式各样的 Web 应用。原本应用 HTTP 协议的 Web 的机制就是对客户端发来的请求，返回事前准备好的内容。 可随着 Web 越来越普及，仅靠这样的做法已不足以应对所有的需求，更需要引入由程序创建 HTML 内容的做法。

CGI（Common Gateway Interface，通用网关接口）是指 Web 服务器在接收到客户端发送过来的请求后转发给程序的一组机制。 在 CGI 的作用下，程序会对请求内容做出相应的动作，比如创建 HTML 等动态内容。使用 CGI 的程序叫做 CGI 程序，通常是用 Perl、 PHP、 Ruby 和 C等编程语言编写而成。

## 10.4 数据发布的格式及语言

XML（eXtensible Markup Language，可扩展标记语言）是一种可按应用目标进行扩展的通用标记语言。 旨在通过使用 XML，使互联网数据共享变得更容易。XML 和 HTML 都是从标准通用标记语言 SGML（Standard GeneralizedMarkup Language）简化而成。与 HTML 相比，它对数据的记录方式做了特殊处理。

RSS（简易信息聚合，也叫聚合内容）和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称。两者都用到了 XML。

JSON（JavaScript Object Notation）是一种以 JavaScript（ECMAScript）的对象表示法为基础的轻量级数据标记语言。 能够处理的数据类型有false/null/true/ 对象 / 数组 / 数字 / 字符串，这 7 种类型。

```
{"name": "Web Application Security", "num": "TR001"}
```

JSON 让数据更轻更纯粹，并且 JSON 的字符串形式可被 JavaScript轻易地读入。 当初配合 XML 使用的 Ajax 技术也让 JSON 的应用变得更为广泛。另外，其他各种编程语言也提供丰富的库类，以达到轻便操作JSON 的目的。

# 第十一章 Web的攻击技术

## 11.1 针对Web的攻击技术

简单的 HTTP 协议本身并不存在安全性问题，因此协议本身几乎不会成为攻击的对象。 应用 HTTP 协议的服务器和客户端，以及运行在服务器上的 Web 应用等资源才是攻击目标。

HTTP 不具备必要的安全功能。从整体上看， HTTP 就是一个通用的单纯协议机制。因此它具备较多优势，但是在安全性方面则呈劣势。就拿远程登录时会用到的 SSH 协议来说， SSH 具备协议级别的认证及会话管理等功能， HTTP 协议则没有。另外在架设 SSH 服务方面，任何人都可以轻易地创建安全等级高的服务， 而 HTTP 即使已架设好服务器，但若想提供服务器基础上的 Web 应用，很多情况下都需要重新开发。

在客户端即可篡改请求。在 HTTP 请求报文内加载攻击代码，就能发起对 Web 应用的攻击。通过 URL 查询字段或表单、 HTTP 首部、 Cookie 等途径把攻击代码传入，若这时 Web 应用存在安全漏洞，那内部信息就会遭到窃取，或被攻击者拿到管理权限。

对 Web 应用的攻击模式有以下两种。
- 主动攻击
- 被动攻击

以服务器为目标的主动攻击。主动攻击（active attack）是指攻击者通过直接访问 Web 应用，把攻击代码传入的攻击模式。 由于该模式是直接针对服务器上的资源进行攻击，因此攻击者需要能够访问到那些资源。主动攻击模式里具有代表性的攻击是 SQL 注入攻击和 OS 命令注入攻击。

以服务器为目标的被动攻击。被动攻击（passive attack）是指利用圈套策略执行攻击代码的攻击模式。在被动攻击过程中，攻击者不直接对目标 Web 应用访问发起攻击。

## 11.2 因输出值转义不完全引发的安全漏洞

实施 Web 应用的安全对策可大致分为以下两部分。

- 客户端的验证
- Web 应用端（服务器端）的验证

跨站脚本攻击（Cross-Site Scripting， XSS）是指通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript进行的一种攻击。 动态创建的 HTML 部分有可能隐藏着安全漏洞。就这样，攻击者编写脚本设下陷阱，用户在自己的浏览器上运行时，一不小心就会受到被动攻击。

跨站脚本攻击有可能造成以下影响。
- 利用虚假输入表单骗取用户个人信息。
- 利用脚本窃取用户的 Cookie 值，被害者在不知情的情况下，帮助攻击者发送恶意请求。
- 显示伪造的文章或图片。

会执行非法SQL的SQL注入攻击。SQL 注入（SQL Injection）是指针对 Web 应用使用的数据库，通过运行非法的 SQL 而产生的攻击。该安全隐患有可能引发极大的威胁，有时会直接导致个人信息及机密信息的泄露。Web 应用通常都会用到数据库，当需要对数据库表内的数据进行检索或添加、删除等操作时，会使用 SQL 语句连接数据库进行特定的操作。如果在调用 SQL 语句的方式上存在疏漏，就有可能执行被恶意注入（Injection）非法 SQL 语句。SQL 注入攻击有可能会造成以下等影响。
- 非法查看或篡改数据库内的数据
- 规避认证
- 执行和数据库服务器业务关联的程序等

OS 命令注入攻击（OS Command Injection）是指通过 Web 应用，执行非法的操作系统命令达到攻击的目的。 只要在能调用 Shell 函数的地方就有存在被攻击的风险。可以从 Web 应用中通过 Shell 来调用操作系统命令。倘若调用 Shell时存在疏漏，就可以执行插入的非法 OS 命令。OS 命令注入攻击可以向 Shell 发送命令，让 Windows 或 Linux 操作系统的命令行启动程序。 也就是说，通过 OS 注入攻击可执行 OS 上安装着的各种程序。

HTTP 首部注入攻击（HTTP Header Injection）是指攻击者通过在响应首部字段内插入换行， 添加任意响应首部或主体的一种攻击。属于被动攻击模式。向首部主体内添加内容的攻击称为 HTTP 响应截断攻击（HTTP Response Splitting Attack）。

HTTP 首部注入攻击有可能会造成以下一些影响。
- 设置任何 Cookie 信息
- 重定向至任意 URL
- 显示任意的主体（HTTP 响应截断攻击）

HTTP 响应截断攻击是用在 HTTP 首部注入的一种攻击。攻击顺序相同，但是要将两个 %0D%0A%0D%0A 并排插入字符串后发送。利用这两个连续的换行就可作出 HTTP 首部与主体分隔所需的空行了，这样就能显示伪造的主体， 达到攻击目的。这样的攻击叫做 HTTP 响应截断攻击。

邮件首部注入（Mail Header Injection）是指 Web 应用中的邮件发送功能，攻击者通过向邮件首部 To 或 Subject 内任意添加非法内容发起的攻击。利用存在安全漏洞的 Web 网站，可对任意邮件地址发送广告邮件或病毒邮件。

目录遍历（Directory Traversal）攻击是指对本无意公开的文件目录，通过非法截断其目录路径后， 达成访问目的的一种攻击。这种攻击有时也称为路径遍历（Path Traversal）攻击。通过 Web 应用对文件处理操作时，在由外部指定文件名的处理存在疏漏的情况下， 用户可使用 .../ 等相对路径定位到 /etc/passed 等绝对路径上，因此服务器上任意的文件或文件目录皆有可能被访问到。这样一来，就有可能非法浏览、篡改或删除 Web 服务器上的文件。固然存在输出值转义的问题， 但更应该关闭指定对任意文件名的访问权限。

远程文件包含漏洞（Remote File Inclusion）是指当部分脚本内容需要从其他文件读入时， 攻击者利用指定外部服务器的 URL 充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。这主要是 PHP 存在的安全漏洞，对 PHP 的 include 或 require 来说，这是一种可通过设定，指定外部服务器的 URL 作为文件名的功能。但是，该功能太危险， PHP5.2.0 之后默认设定此功能无效。固然存在输出值转义的问题，但更应控制对任意文件名的指定。

## 11.3 因设置或设计上的缺陷引发的安全漏洞

因设置或设计上的缺陷引发的安全漏洞是指，错误设置 Web 服务器，或是由设计上的一些问题引起的安全漏洞。

强制浏览（Forced Browsing）安全漏洞是指，从安置在 Web 服务器的公开目录下的文件中，浏览那些原本非自愿公开的文件。强制浏览有可能会造成以下一些影响。
- 泄露顾客的个人信息等重要情报
- 泄露原本需要具有访问权限的用户才可查阅的信息内容
- 泄露未外连到外界的文件

不正确的错误消息处理（Error Handling Vulnerability）的安全漏洞是指， Web 应用的错误信息内包含对攻击者有用的信息。与 Web 应用有关的主要错误信息如下所示。
- Web 应用抛出的错误消息
- 数据库等系统抛出的错误消息

开放重定向（Open Redirect）是一种对指定的任意 URL 作重定向跳转的功能。而于此功能相关联的安全漏洞是指，假如指定的重定向URL 到某个具有恶意的 Web 网站，那么用户就会被诱导至那个 Web网站。

## 11.4 因会话管理疏忽引发的安全漏洞

会话管理是用来管理用户状态的必备功能，但是如果在会话管理上有所疏忽，就会导致用户的认证状态被窃取等后果。

会话劫持（Session Hijack）是指攻击者通过某种手段拿到了用户的会话 ID，并非法使用此会话 ID 伪装成用户，达到攻击的目的。

下面列举了几种攻击者可获得会话 ID 的途径。
- 通过非正规的生成方法推测会话 ID
- 通过窃听或 XSS 攻击盗取会话 ID
- 通过会话固定攻击（Session Fixation）强行获取会话 ID

会话固定攻击。对以窃取目标会话 ID 为主动攻击手段的会话劫持而言，会话固定攻击（Session Fixation）攻击会强制用户使用攻击者指定的会话 ID，属于被动攻击。

跨站点请求伪造（Cross-Site Request Forgeries， CSRF）攻击是指攻击者通过设置好的陷阱， 强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新，属于被动攻击。跨站点请求伪造有可能会造成以下等影响。
- 利用已通过认证的用户权限更新设定信息等
- 利用已通过认证的用户权限购买商品
- 利用已通过认证的用户权限在留言板上发表言论

## 11.5 其他安全漏洞

密码破解攻击（Password Cracking）即算出密码，突破认证。攻击不仅限于 Web 应用，还包括其他的系统（如 FTP 或 SSH 等），本节将会讲解对具备认证功能的 Web 应用进行的密码破解。

点击劫持（Clickjacking）是指利用透明的按钮或链接做成陷阱，覆盖在 Web 页面之上。然后诱使用户在不知情的情况下，点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装（UI Redressing）。

DoS 攻击（Denial of Service attack）是一种让运行中的服务呈停止状态的攻击。 有时也叫做服务停止攻击或拒绝服务攻击。 DoS 攻击的对象不仅限于 Web 网站，还包括网络设备及服务器等。

后门程序（Backdoor）是指开发设置的隐藏入口，可不按正常步骤使用受限功能。利用后门程序就能够使用原本受限制的功能。