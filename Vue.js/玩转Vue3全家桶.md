> 玩转 Vue 3 全家桶  
> 大圣 前百度前端架构师  
> [课程地址](https://time.geekbang.org/column/intro/100094401)

# 玩转 Vue3 全家桶

## 建构前端知识体系

### 为什么要学 Vue3

在目前的前端开发中，流行的框架相信你并不陌生。它们的目标都是为了帮助开发者高效地开发 Web 应用，只不过走的路线略显不同，比如 React 注重数据不可变、虚拟 DOM 和运行时；而 Svelte 运行时都非常轻量级，侧重在于编译时的优化；Angular 则在抽象这个维度又走向一个极致，生来就是为了复杂项目。
每个流行框架的内部，都有一大堆的最佳实践。而相比之下，Vue 就简单多了，简单到大部分前端开发者都能学得会。Vue 在每个维度之间，做了非常好的权衡和取舍，算是一个非常中庸且优雅的框架，兼顾响应式、虚拟 DOM、运行时和编译优化。
而且 Vue 3 作为 Vue 框架最新的版本，有很多优秀的设计相信你会非常喜欢，例如 Composition 组合 API、基于 Proxy 的响应式系统、自定义渲染器等。
这些设计可以让我们以很轻松的方式，从最熟悉的框架逐渐深入底层。学习 Vue 3 的同时，我们就可以去回顾 Vue 1 和 Vue 2，直观地感受 Vue 框架发展的过程。在此基础上，我们再去横向对比 Angular、React、Svelte 等框架，最终是可以把学到的知识点串成一个网络的。这不仅是加强记忆那么简单，还能大大开阔你的前端视野。

### 如何学习 Vue3

既然我们已经锚定了 Vue 3 这个出发点，那么该如何学习它呢？
Vue 3 已经是上手最简单的框架了，如果你没有 Vue 2 的经验，可以直接走 Vite+Option 先熟悉模板的语法，把官网的入门教程先走一遍，然后再去研究 Vue 3 的新特性。
不过，如果你没有 Vue 2 的经验，或者 Vue 基础比较薄弱，也不用害怕，你可以跟着我的脚步，往下学《上手：一个清单应用帮你入门 Vue.js》这一讲。在这里，即便你不熟悉 Vue，也能先体验一把 Vue。
而如果你已经是 Vue 2 的开发者，那么上手 Vue 3 就更简单了，直接去熟悉 Composition API 的新语法就可以了，我们专栏中的项目也会主要用 Composition API 来组织。
入门以后，我们就可以正式探索冰山了。但进阶之路还是要慢慢走，我们会逐步补齐要学习的下面这些版块的内容，从而帮你构建出一个完整的前端知识体系。

## 什么是好的项目?

## 深入 TypeScript

## 一、课程导读篇

### 01. 宏观视角:从前端框架发展史聊聊为什么要学 Vue 3 ?

#### 前端三大框架

在前端 MVVM 模式下，不同框架的目标都是一致的，就是利用数据驱动页面，但是怎么处理数据的变化，各个框架走出了不同的路线。

这些框架要回答的核心问题就是，数据发生变化后，我们怎么去通知页面更新。各大框架在这个步骤上，各显神通：
Angular 1 就是最老套的脏检查。所谓的脏检查，指的是 Angular 1 在对数据变化的检查上，遵循每次用户交互时都检查一次数据是否变化，有变化就去更新 DOM 这一方法。这个方法看似简单粗暴，但算是数据驱动页面早期的实现，所以一经推出，就迅速占领了 MVVM 市场。
后面 Angular 团队自断双臂，完全抛弃 Angular 1，搞了一个全新的框架还叫 Angular，引入了 TypeScript、RxJS 等新内容，虽然这些设计很优秀，但是不支持向前兼容，抛弃了老用户。这样做也伤了一大批 Angular 1 用户的心，包括我。这也是 Angular 这个优秀的框架现在在国内没有大面积推广的原因。
而 Vue 1 的解决方案，就是使用响应式，初始化的时候，Watcher 监听了数据的每个属性，这样数据发生变化的时候，我们就能精确地知道数据的哪个 key 变了，去针对性修改对应的 DOM 即可，这一过程可以按如下方式解构：

在上图中，左边是实际的网页内容，我们在网页中使用`{{}}`渲染一个变量，Vue 1 就会在内容里保存一个监听器监控这个变量，我们称之为 Watcher，数据有变化，watcher 会收到通知去更新网页。
通俗来说，如果把网页数据看成你管理的员工，普通数据就是那种每次你都需要找到他，告诉他要怎么做的人，响应式数据就是他本身有任何变化，都会主动给你发日报告诉你的积极员工。
此外，Facebook 的 React 团队提出了不同于上面的 Angular、Vue 的的解决方案，他们设计了 React 框架，在页面初始化的时候，在浏览器 DOM 之上，搞了一个叫虚拟 DOM 的东西，也就是用一个 JavaScript 对象来描述整个 DOM 树。我们可以很方便的通过虚拟 DOM 计算出变化的数据，去进行精确的修改。
我们先看 React 中的一段代码：

```js
<div id="app">
  <p class="item">Item1</p>
  <div class="item">Item2</div>
</div>
```

在 React 中，这样一段 HTML 会被映射成一个 JavaScript 的对象进行描述。这个对象就像数据和实际 DOM 的一个缓存层，通过管理这个对象的变化，来减少对实际 DOM 的操作。
这种形式不仅让性能有个很好的保障，我们还多了一个用 JSON 来描述网页的工具，并且让虚拟 DOM 这个技术脱离了 Web 的限制。因为积累了这么多优势，虚拟 DOM 在小程序，客户端等跨端领域大放异彩。
虚拟 DOM 在运行的时候就是这么一个对象：

```js
{
  tag: "div",
  attrs: {
    id: "app"
  },
  children: [
    {
      tag: "p",
      attrs: { className: "item" },
      children: ["Item1"]
    },
    {
      tag: "div",
      attrs: { className: "item" },
      children: ["Item2"]
    }
  ]
}
```

这个对象完整地描述了 DOM 的树形结构，这样数据有变化的时候，我们生成一份新的虚拟 DOM 数据，然后再对之前的虚拟 DOM 进行计算，算出需要修改的 DOM，再去页面进行操作。
浏览器操作 DOM 一直都是性能杀手，而虚拟 DOM 的 Diff 的逻辑，又能够确保尽可能少的操作 DOM，这也是虚拟 DOM 驱动的框架性能一直比较优秀的原因之一。

#### Vue 与 React 框架的对比

通过上面对前端三大框架的介绍，我们不难发现 Vue 和 React 在数据发生变化后，在通知页面更新的方式上有明显的不同，通俗的来说，就是：在 Vue 框架下，如果数据变了，那框架会主动告诉你修改了哪些数据；而 React 的数据变化后，我们只能通过新老数据的计算 Diff 来得知数据的变化。
这两个解决方案都解决了数据变化后，如何通知页面更新的问题，并且迅速地获得了很高的占有率，但是他们都碰到了性能的瓶颈：

1. 对于 Vue 来说，它的一个核心就是“响应式”，也就是数据变化后，会主动通知我们。响应式数据新建 Watcher 监听，本身就比较损耗性能，项目大了之后每个数据都有一个 watcher 会影响性能。
2. 对于 React 的虚拟 DOM 的 Diff 计算逻辑来说，如果虚拟 DOM 树过于庞大，使得计算时间大于 16.6ms，那么就可能会造成性能的卡顿。
   为了解决这种性能瓶颈， Vue 和 React 走了不同的道路。
   React 为了突破性能瓶颈，借鉴了操作系统时间分片的概念，引入了 Fiber 架构。通俗来说，就是把整个虚拟 DOM 树微观化，变成链表，然后我们利用浏览器的空闲时间计算 Diff。一旦浏览器有需求，我们可以把没计算完的任务放在一旁，把主进程控制权还给浏览器，等待浏览器下次空闲。
   这种架构虽然没有减少运算量，但是巧妙地利用空闲实现计算，解决了卡顿的问题。你可以看一下我画的图解：

在上图中，左侧是一个树形结构，树形结构的 Diff 很难中断；右侧是把树形结构改造成了链表，遍历严格地按照子元素 -> 兄弟元素 -> 父元素的逻辑，随时可以中断和恢复 Diff 的计算过程。
为了方便你对计算 Diff 的理解，我们来看下面这张图：

这个图里两个虚线之间是浏览器的一帧，高性能的动画要求是 60fps，也就是 1 秒要渲染 60 次，每一帧的时间就是 16.6 毫秒，在这 16.6 毫秒里，浏览器自己的渲染更新任务执行后，会有一部分的空闲时间，这段时间我们就用来计算 Diff。
等到下一帧任务来了，我们就把控制权还给浏览器，让它继续去更新和渲染，等待空闲时间再继续计算，这样就不会导致卡顿。

Vue 1 的问题在于响应式数据过多，这样会带来内存占用过多的问题。所以 Vue 2 大胆引入虚拟 DOM 来解决响应式数据过多的问题。
这个解决方案使用虚拟 DOM 解决了响应式数据过多的内存占用问题，又良好地规避了 React 中虚拟 DOM 的问题， 还通过虚拟 DOM 给 Vue 带来了跨端的能力。看到这个解决方案的时候，我真是一拍大腿，直呼“真牛！”。
响应式数据是主动推送变化，虚拟 DOM 是被动计算数据的 Diff，一个推一个拉，它们看起来是两个方向的技术，但被 Vue 2 很好地融合在一起，采用的方式就是组件级别的划分。
对于 Vue 2 来说，组件之间的变化，可以通过响应式来通知更新。组件内部的数据变化，则通过虚拟 DOM 去更新页面。这样就把响应式的监听器，控制在了组件级别，而虚拟 DOM 的量级，也控制在了组件的大小。
这个方案也体现了 Vue 一直以来坚持的中庸的设计思想。
下图左边就是一个个的组件，组件内部是没有 Watcher 监听器的，而是通过虚拟 DOM 来更新，每个组件对应一个监听器，大大减小了监听器的数量。

除了响应式和虚拟 DOM 这个维度，Vue 和 React 还有一些理念和路线的不同，在模板的书写上，也走出了 template 和 JSX 两个路线。

React 的世界里只有 JSX，最终 JSX 都会在 Compiler 那一层，也就是工程化那里编译成 JS 来执行，所以 React 最终拥有了全部 JS 的动态性，这也导致了 React 的 API 一直很少，只有 state、hooks、Component 几个概念，主要都是 JavaScript 本身的语法和特性。
而 Vue 的世界默认是 template，也就是语法是限定死的，比如 v-if 和 v-for 等语法。有了这些写法的规矩后，我们可以在上线前做很多优化。Vue 3 很优秀的一个点，就是在虚拟 DOM 的静态标记上做到了极致，让静态的部分越过虚拟 DOM 的计算，真正做到了按需更新，很好的提高了性能。

在模板的书写上，除了 Vue 和 React 走出的 template 和 JSX 两个路线，还出现了 Svelte 这种框架，没有虚拟 DOM 的库，直接把模板编译成原生 DOM，几乎没有 Runtime，所有的逻辑都在 Compiler 层优化，算是另外一个极致。

### 02. 上手: 一个清单应用带你入门 Vue.js

计算属性全选框功能

```html
<div>
  全选<input type="checkbox" v-model="allDone">
  <span> {{active}}  / {{all}} </span>
</div>
<script>
computed:{
  active(){
    return this.todos.filter(v=>!v.done).length
  },
  all(){
    return this.todos.length
  },
  allDone: {
      get: function () {
        return this.active === 0
      },
      set: function (val) {
        this.todos.forEach(todo=>{
          todo.done = val
        });
      }
  }
}
</script>
```

### 03. 新特性:初探 Vue 3 新特性

Vue 2 的核心模块和历史遗留问题

1. 开发维护，使用停止维护的 Flow.js 来做类型校验；
2. 社区二次维护困难，内部运行时执行浏览器 API 导致跨端方案出现问题；
3. 响应式不是真正意义上的代理，知识利用 defineProperty 进行属性拦截；
4. Option API 在组织代码中不易维护，对 TS 的类型推导不友好；

从七个方面了解 Vue 3 新特性

1. Vue 团队开发的工作方式：RFC 机制；
2. 响应式机制使用 Proxy 代理代替 define Property 拦截；
3. 自定义渲染器，使用 monorepo 管理方式，渲染的逻辑也拆成了平台无关渲染逻辑和浏览器渲染 API 两部分；
4. 全部模块使用 TypeScript 重构，给系统带来更方便的提示和让代码更健壮；
5. Composition API 组合语法，对 Tree- shaking 友好，代码方便复用；
6. 内置了 Fragment/Teleport/Suspense 新组建；
7. 新一代工程化工具 Vite；

### 04. 升级:Vue2 项目如何升级到 Vue3?

Vue 3 的 Composition API 带来的代码组织方式更利于封装代码，维护起来也不会上下横跳。

Vue 3 也不是没有问题，由于新的响应式系统用了 Proxy，会存在兼容性问题。

## 二、基础入门篇

### 05. 项目启动:搭建 Vue 3 工程化项目第一步

```
Vue 3 项目
VS Code编辑器   Chrome浏览器
Volar语法提示   Devtools调试工具
CSS 预处理  网络请求    Element3 组件库
Vuex 管理数据   Vue 3   vue-router 路由
Vite 工程化     代码规范/研发规范
Node.js
单元测试   发布部署
```

### 06. 新的代码组织方式: Composition API + script setup 到底好在哪里?

开发上手

1. 使用单文件组件 vue 文件，支持将组件的 HTML、CSS 和 JavaScript 写在单个文件内容中；
2. 对于 ref 返回的响应式数据，我们需要修改 `.value` 才能生效，而在 `<script setup>` 标签内定义的变量和函数，都可以在模板中直接使用；
3. script setup 自动把 import 引入的组件注册到当前组件中；
4. 计算属性和生命周期等功能，都可以脱离 Vue 的组件机制单独使用；
5. script setup 可以让代码变得更加精简和高效；

style 样式的特性


1. 添加 scoped 属性避免样式冲突问题；
2. 全局的样式可以使用 `:global` 来标记；
3. 通过 v-bind 函数直接在 CSS 中使用JavaScript 中的变量；


### 07. 巧妙的响应式:深入理解 Vue 3 的响应式机制

JavaScript 里面的变量是没有响应式的概念的，代码自上而下执行。

#### 响应式原理

Vue 中用过三种响应式解决方案：defineProperty/Proxy/value setter。

defineProperty 在对象的属性中实现了拦截，读取属性的时候执行 get 函数，修改属性时执行 set 函数。单语法也有一些缺陷，删除属性并不会触发 set 函数。

Proxy 是针对对象来监听，而不是针对某个具体属性，所以不仅可以代理那些定义时不存在的属性，还可以代理更丰富的数据结构，比如 Map/Set 等。Vue 3 的reactive 函数可以把一个对象变成响应式数据，而 reactive 就是基于 Proxy 实现的，还可以通过 watchEffect 执行代理的副作用。

Vue3中还有另外一个响应式实现的逻辑，就是利用对象的 get 和 set 函数来进行监听。这种响应式的实现方式，只能拦截某一个属性的修改，这也是 Vue3 中 ref 这个API 的实现。

| 实现原理 | 实际场景 | 优势 | 劣势 | 实际应用 |
|---|---|---|---|---|
| defineProperty | Vue 2 响应式 | 兼容性 | 数组和属性删除等拦截不了 | Vue 2 |
| Proxy | Vue 3 reactive | 基于Proxy实现真正的拦截 | 兼容不了IE11 | Vue 3 复杂数据结构 |
| value setter | Vue 3 ref | 实现简单 | 只拦截了value属性 | Vue 3 简单数据结构 |

定制响应式数据

watchEffect 函数可以在数据变化之后执行指定的函数。

Vueuse 工具包

封装更多的类似 useStorage 函数的其他 use 类型的函数，把实际开发中你用到的任何数据或者浏览器属性，都封装成响应式数据，这样就可以极大地提高我们的开发效率。Vue 社区中其实已经有一个类似的工具集合，也就是 VueUse，它把开发中常见的属性都封装成为响应式函数。

### 08. 组件化:如何像搭积木一样开发网页?

### 09. 动画: Vue 中如何实现动画效果?

## 三、全家桶实战篇

### 10. 数据流:如何使用 Vuex 设计你的数据流

### 11. 路由:新一代 vue-router 带来什么变化?

### 12. 调试:提高开发效率必备的 Vue Devtools

### 13. JSX:如何利用 JSX 应对更灵活的开发场景?

### 14. TypeScript: Vue 3 中如何使用 TypeScript

### 15. 实战痛点 1:复杂 Vue 项目的规范和基础库封装

### 16. 实战痛点 2:项目开发中的权限系统

### 17. 实战痛点 3: Vue 3 中如何集成第三方框架

### 18. 实战痛点 4:Vue3 项目中的性能优化

### 19. 实战痛点 5:如何打包发布你的 Vue 3 应用?

## 四、Vue 3 进阶开发篇

### 20. 组件库:如何设计你自己的通用组件库?

### 21. 单元测试:如何使用 TDD 开发一个组件?

### 22. 表单:如何设计一个表单组件?

### 23. 弹窗:如何设计一个弹窗组件?

### 24. 树:如何设计一个树形组件?

### 25. 表格:如何设计一个表格组件?

### 26. 文档:如何给你的组件库设计一个可交互式文档?

### 27. 自定义渲染器:如何实现 Vue 的跨端渲染?

## 五、Vue 3 生态源码篇

### 28. 响应式:万能面试题，怎么手写响应式系统

### 29. 运行时: Vue 在浏览器里是怎么跑起来的?

### 30. 虚拟 DOM(上):如何通过虚拟 DOM 更新页面?

### 31. 虚拟 DOM(下):想看懂虚拟 DOM 算法，先刷个算法题.

### 32. 编译原理(上):手写一个迷你 Vue 3 Compiler 的入门原理

### 33. 编译原理(中): Vue Compiler 模块全解析

### 34. 编译原理(下):编译原理给我们带来了什么?

### 35. Vite 原理:写一个迷你的 Vite

### 36. 数据流原理: Vuex & Pinia 源码剖析

### 37. 前端路由原理: vue- -router 源码剖析

### 38. 服务端渲染原理: Vue 3 中的 SSR 是如何实现的?

## Vue 3 生态源码到底给我们带来了什么?
