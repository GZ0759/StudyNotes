> 你不知道的JavaScript（上卷） 
> You Don’t Know JavaScript: Scope & Closures this & Object Prototypes
> 2015年 4 月第1版   

<!-- TOC -->

- [第一部分 作用域与闭包](#第一部分-作用域与闭包)
  - [第1章 作用域是什么](#第1章-作用域是什么)
    - [1.1  编译原理](#11--编译原理)
    - [1.2  理解作用域](#12--理解作用域)
    - [1.3  作用域嵌套](#13--作用域嵌套)
    - [1.4 异常](#14-异常)
  - [第2章 词法作用域](#第2章-词法作用域)
    - [2.1 词法阶段](#21-词法阶段)
    - [2.2 欺骗词法](#22-欺骗词法)
  - [第3章 函数作用域和块作用域](#第3章-函数作用域和块作用域)
    - [3.1 函数中的作用域](#31-函数中的作用域)
    - [3.3 函数作用域](#33-函数作用域)
    - [3.4 块作用域](#34-块作用域)
  - [第4章 提升](#第4章-提升)
    - [4.2 编译器再度来袭](#42-编译器再度来袭)
    - [4.3 函数优先](#43-函数优先)
  - [第5章 作用域闭包](#第5章-作用域闭包)
    - [5.1 启示](#51-启示)
    - [5.2 实质问题](#52-实质问题)
    - [5.3 现在我懂了](#53-现在我懂了)
    - [5.4 循环和闭包](#54-循环和闭包)
    - [5.5 模块](#55-模块)
  - [附录A 动态作用域](#附录a-动态作用域)
  - [附录B 块作用域的替代方案](#附录b-块作用域的替代方案)
  - [附录C this词法](#附录c-this词法)
- [第二部分 this和对象原型](#第二部分-this和对象原型)
  - [第1章 关于this](#第1章-关于this)
    - [1.1 为什么要用this](#11-为什么要用this)
    - [1.2 误解](#12-误解)
    - [1.3 this到底是什么](#13-this到底是什么)
  - [第2章 this全面解析](#第2章-this全面解析)
    - [2.1 调用位置](#21-调用位置)
    - [2.2 绑定规则](#22-绑定规则)
    - [2.3 优先级](#23-优先级)
    - [2.4 绑定例外](#24-绑定例外)
    - [2.5 this词法](#25-this词法)
  - [第3章 对象](#第3章-对象)
    - [3.1 语法](#31-语法)
    - [3.2 类型](#32-类型)
    - [3.3 内容](#33-内容)
    - [3.4 遍历](#34-遍历)
  - [第4章 混合对象“类”](#第4章-混合对象类)
    - [4.1 类理论](#41-类理论)
    - [4.2 类的机制](#42-类的机制)
    - [4.3 类的继承](#43-类的继承)
    - [4.4 混入](#44-混入)
  - [第5章 原型](#第5章-原型)
    - [5.1 [[Prototype]]](#51-prototype)
    - [5.2 “类”](#52-类)
    - [5.3 （原型） 继承](#53-原型-继承)
    - [5.4 对象关联](#54-对象关联)
  - [第6章 行为委托](#第6章-行为委托)
    - [6.1 面向委托的设计](#61-面向委托的设计)
    - [6.2 类与对象](#62-类与对象)
    - [6.3 更简洁的设计](#63-更简洁的设计)
    - [6.4 更好的语法](#64-更好的语法)
    - [6.5 内省](#65-内省)
  - [附录A ES6中的Class](#附录a-es6中的class)

<!-- /TOC -->

# 第一部分 作用域与闭包

## 第1章 作用域是什么

变量住在哪里？ 换句话说， 它们储存在哪里？ 最重要的是， 程序需要时如何找到它们？ 这些问题说明需要一套设计良好的规则来存储变量， 并且之后可以方便地找到这些变量。 这套规则被称为作用域。  

### 1.1  编译原理

首先， JavaScript 引擎不会有大量的（像其他语言编译器那么多的） 时间用来进行优化， 因 为与其他语言不同， JavaScript 的编译过程不是发生在构建之前的。 

对于 JavaScript 来说， 大部分情况下编译发生在代码执行前的几微秒（甚至更短）的时间内。 在我们所要讨论的作用域背后， JavaScript 引擎用尽了各种办法（比如 JIT， 可以延迟编译甚至实施重编译） 来保证性能最佳。

 简单地说， 任何 JavaScript 代码片段在执行前都要进行编译（ 通常就在执行前）。 因此， JavaScript 编译器首先会对 var a = 2; 这段程序进行编译， 然后做好执行它的准备， 并且通常马上就会执行它。  

### 1.2  理解作用域

- 引擎，从头到尾负责整个 JavaScript 程序的编译及执行过程。
- 编译器，引擎的好朋友之一， 负责语法分析及代码生成等脏活累活。
- 作用域，引擎的另一位好朋友， 负责收集并维护由所有声明的标识符（变量） 组成的一系列查询， 并实施一套非常严格的规则， 确定当前执行的代码对这些标识符的访问权限。  

引擎会为变量 a 进行 LHS 查询。 另外一个查找的类型叫作 RHS。  当变量出现在赋值操作的左侧时进行 LHS 查询， 出现在右侧时进行 RHS 查询。讲得更准确一点， RHS 查询与简单地查找某个变量的值别无二致， 而 LHS 查询则是试图 找到变量的容器本身， 从而可以对其赋值。 从这个角度说， RHS 并不是真正意义上的“赋值操作的右侧”， 更准确地说是“非左侧”。你可以将 RHS 理解成 retrieve his source value（ 取到它的源值）， 这意味着“得到某某的 值”。  

### 1.3  作用域嵌套

当一个块或函数嵌套在另一个块或函数中时， 就发生了作用域的嵌套。遍历嵌套作用域链的规则很简单： 引擎从当前的执行作用域开始查找变量， 如果找不到， 就向上一级继续查找。 当抵达最外层的全局作用域时， 无论找到还是没找到， 查找过程都 会停止。  

### 1.4 异常

为什么区分 LHS 和 RHS 是一件重要的事情？ 因为在变量还没有声明（在任何作用域中都无法找到该变量）的情况下， 这两种查询的行为是不一样的。如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量， 引擎就会抛出 ReferenceError 异常。 值得注意的是， ReferenceError 是非常重要的异常类型 。

相较之下， 当引擎执行 LHS 查询时， 如果在顶层（全局作用域） 中也无法找到目标变量， 全局作用域中就会创建一个具有该名称的变量， 并将其返还给引擎， 前提是程序运行在非 “严格模式” 下。  

ES5 中引入了“严格模式”。 同正常模式， 或者说宽松 / 懒惰模式相比， 严格模式在行为上 有很多不同。 其中一个不同的行为是严格模式禁止自动或隐式地创建全局变量。 因此， 在 严格模式中 LHS 查询失败时， 并不会创建并返回一个全局变量， 引擎会抛出同 RHS 查询失败时类似的 ReferenceError 异常。  

接下来， 如果 RHS 查询找到了一个变量， 但是你尝试对这个变量的值进行不合理的操作， 比如试图对一个非函数类型的值进行函数调用， 或着引用 null 或 undefined 类型的值中的属性， 那么引擎会抛出另外一种类型的异常， 叫作 TypeError。 

ReferenceError 同作用域判别失败相关， 而 TypeError 则代表作用域判别成功了， 但是对结果的操作是非法或不合理的。  

## 第2章 词法作用域

作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域，另外一种叫作动态作用域， 仍有一些编程语言在使用（比如 Bash 脚本、 Perl 中的一些模式等）。  

### 2.1 词法阶段

大部分标准语言编译器的第一个工作阶段叫作词法化（也叫单词化）。 词法化的过程会对源代码中的字符进行检查， 如果是有状态的解析过程， 还会赋予单词语义。简单来说，词法作用域就是定义在词法阶段的作用域。作用域查找会在找到第一个匹配的标识符时停止。换句话说， 词法作用域是由你在写 代码时将变量和块作用域写在哪里来决定的， 因此当词法分析器处理代码时会保持作用域 不变（大部分情况下是这样的）。  

作用域气泡的结构和互相之间的位置关系给引擎提供了足够的位置信息， 引擎用这些信息 来查找标识符的位置。  

作用域查找会在找到第一个匹配的标识符时停止。 在多层的嵌套作用域中可以定义同名的标识符， 这叫作“遮蔽效应”（内部的标识符“遮蔽” 了外部的标识符）。 抛开遮蔽效应， 作用域查找始终从运行时所处的最内部作用域开始， 逐级向外或者说向上进行， 直到遇见 第一个匹配的标识符为止。  

### 2.2 欺骗词法

欺骗词法作用域会导致性能下降。  

JavaScript 中的 eval(..) 函数可以接受一个字符串为参数， 并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。 换句话说， 可以在你写的代码中用程序生成代码并运行， 就好像代码是写在那个位置的一样。  

在执行 eval(..) 之后的代码时， 引擎并不“知道” 或“在意” 前面的代码是以动态形式插入进来， 并对词法作用域的环境进行修改的。 引擎只会如往常地进行词法作用域查找。  

new Function(..) 函数的行为也很类似， 最后一个参数可以接受代码字符串， 并将其转 化为动态生成的函数（前面的参数是这个新生成的函数的形参）。 这种构建函数的语法比 eval(..) 略微安全一些， 但也要尽量避免使用。  

JavaScript 中另一个难以掌握（并且现在也不推荐使用） 的用来欺骗词法作用域的功能是 with 关键字。with 通常被当作重复引用同一个对象中的多个属性的快捷方式， 可以不需要重复引用对象本身。  

eval(..) 函数如果接受了含有一个或多个声明的代码， 就会修改其所处的词法作用域， 而 with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。with 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域， 因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。  

## 第3章 函数作用域和块作用域

### 3.1 函数中的作用域

函数作用域的含义是指， 属于这个函数的全部变量都可以在整个函数的范围内使用及复用（ 事实上在嵌套的作用域中也可以使用）。 这种设计方案是非常有用的， 能充分利用 JavaScript 变量可以根据需要改变值类型的“动态” 特性。  

3.2 隐藏内部实现

对函数的传统认知就是先声明一个函数， 然后再向里面添加代码。 但反过来想也可以带来 一些启示： 从所写的代码中挑选出一个任意的片段， 然后用函数声明对它进行包装， 实际 上就是把这些代码“隐藏” 起来了。  

这个原则可以延伸到如何选择作用域来包含变量和函数。 如果所有变量和函数都在全局作 用域中， 当然可以在所有的内部嵌套作用域中访问到它们。 但这样会破坏前面提到的最小 特权原则， 因为可能会暴漏过多的变量或函数， 而这些变量或函数本应该是私有的， 正确 的代码应该是可以阻止对这些变量或函数进行访问的。  

“隐藏” 作用域中的变量和函数所带来的另一个好处， 是可以避免同名标识符之间的冲突， 两个标识符可能具有相同的名字但用途却不一样， 无意间可能造成命名冲突。 冲突会导致变量的值被意外覆盖。  

第三方库通常会在全局作用域中声明一个名字足够独特的变量， 通常是一个对象。 这个对象被用作库的命名空间， 所有需要暴露给外界的功能都会成为这个对象（ 命名空间） 的属 性， 而不是将自己的标识符暴漏在顶级的词法作用域中。  

另外一种避免冲突的办法和现代的模块机制很接近， 就是从众多模块管理器中挑选一个来使用。 使用这些工具， 任何库都无需将标识符加入到全局作用域中， 而是通过依赖管理器的机制将库的标识符显式地导入到另外一个特定的作用域中。  

3.3 函数

### 3.3 函数作用域

我们已经知道， 在任意代码片段外部添加包装函数， 可以将内部的变量和函数定义“隐藏” 起来， 外部作用域无法访问包装函数内部的任何内容。虽然这种技术可以解决一些问题， 但是它并不理想， 因为会导致一些额外的问题。首先， 必须声明一个具名函数 foo()， 意味着 foo 这个名称本身“污染” 了所在作用域（在这个 例子中是全局作用域）。 其次， 必须显式地通过函数名（foo()） 调用这个函数才能运行其中的代码。  

包装函数的声明以 `(function...` 而不仅是以 `function...` 开始。 尽管看上去这并不是一个很显眼的细节， 但实际上却是非常重要的区别。 函数会被当作函数表达式而不是一 个标准的函数声明来处理。`(function foo(){ .. })` 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问， 外部作用域则不行。 foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。  

IIFE， 代表立即执行函数表达式 （Immediately Invoked Function Expression）。函数被包含在一对 ( ) 括号内部， 因此成为了一个表达式， 通过在末尾加上另外一个 ( ) 可以立即执行这个函数， 比如 `(function foo(){ .. })()`。 第一个 ( ) 将函数变成表 达式， 第二个 ( ) 执行了这个函数。  

相较于传统的 IIFE 形式， 很多人都更喜欢另一个改进的形式： `(function(){ .. }())`。 仔细观察其中的区别。 第一种形式中函数表达式被包含在 ( ) 中， 然后在后面用另一个 () 括 号来调用。 第二种形式中用来调用的 () 括号被移进了用来包装的 ( ) 括号中。这两种形式在功能上是一致的。 选择哪个全凭个人喜好。  

IIFE 的另一个非常普遍的进阶用法是把它们当作函数调用并传递参数进去。  我们将 window 对象的引用传递进去， 但将参数命名为 global， 因此在代码风格上对全局 对象的引用变得比引用一个没有“全局” 字样的变量更加清晰。  

```js
var a = 2;

(function IIFE( global ){

	var a = 3;
	console.log( a ); // 3
	console.log( global.a ); // 2

})( window );

console.log( a ); // 2
```

这个模式的另外一个应用场景是解决 undefined 标识符的默认值被错误覆盖导致的异常（虽 然不常见）。 将一个参数命名为 undefined， 但是在对应的位置不传入任何值， 这样就可以 保证在代码块中 undefined 标识符的值真的是 undefined 。

IIFE 还有一种变化的用途是倒置代码的运行顺序， 将需要运行的函数放在第二位， 在 IIFE 执行之后当作参数传递进去。 这种模式在 UMD（Universal Module Definition） 项目中被广 泛使用。   

### 3.4 块作用域

我们在 for 循环的头部直接定义了变量 i， 通常是因为只想在 for 循环内部的上下文中使 用 i， 而忽略了 i 会被绑定在外部作用域（函数或全局） 中的事实。 这就是块作用域的用处。 变量的声明应该距离使用的地方越近越好， 并最大限度地本地化。但是， 当使用 var 声明变量时， 它写在哪里都是一样的， 因为它们最终都会属于外部作用域。 这段代码是为了风格更易读而伪装出的形式上的块作用域。

with不仅是一个难于理解的结构， 同时也是块作用域的一 个例子（块作用域的一种形式）， 用 with 从对象中创建出的作用域仅在 with 声明中而非外 部作用域中有效。  

avaScript 的 ES3 规范中规定 try/catch 的 catch 分句会创建一个块作用域， 其中声明的变量仅在 catch 内部有效。  

let 关键字可以将变量绑定到所在的任意作用域中（通常是 { .. } 内部）。 换句话说， let 为其声明的变量隐式地了所在的块作用域。  

用 let 将变量附加在一个已经存在的块作用域上的行为是隐式的。 在开发和修改代码的过程中， 如果没有密切关注哪些块作用域中有绑定的变量， 并且习惯性地移动这些块或者将其包含在其他的块中， 就会导致代码变得混乱。 为块作用域显式地创建块可以部分解决这个问题， 使变量的附属关系变得更加清晰。 通常来讲， 显式的代码优于隐式或一些精巧但不清晰的代码。 显式的块作用域风格非常容易书写， 并且和其他语言中块作用域的工作原理一致。在这个例子中， 我们在 if 声明内部显式地创建了一个块， 如果需要对其进行重构， 整个块都可以被方便地移动而不会对外部 if 声明的位置和语义产生任何影响。  

```js
var foo = true;

if (foo) {
	{ // <-- explicit block
		let bar = foo * 2;
		bar = something( bar );
		console.log( bar );
	}
}

console.log( bar ); // ReferenceError
```

但是使用 let 进行的声明不会在块作用域中进行提升。 声明的代码被运行之前， 声明并不 “存在”。

另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关。

for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中， 事实上它将其重新绑定到了循环的每一个迭代中， 确保使用上一个循环迭代结束时的值重新进行赋值。 

除了 let 以外， ES6 还引入了 const， 同样可以用来创建块作用域变量， 但其值是固定的 （常量）。 之后任何试图修改值的操作都会引起错误。   

## 第4章 提升

4.1 先有鸡还是先有蛋

### 4.2 编译器再度来袭

引擎会在解释 JavaScript 代码之前首先对其进行编译。 编译阶段中的一部分工作就是找到所有的声明， 并用合适的作用域将它们关联起来。因此， 正确的思考思路是， 包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。    

因此， 打个比方， 这个过程就好像变量和函数声明从它们在代码中出现的位置被“移动” 到了最上面。 这个过程就叫作提升。  只有声明本身会被提升， 而赋值或其他运行逻辑会留在原地。另外值得注意的是， 每个作用域都会进行提升操作。

函数声明会被提升， 但是函数表达式却不会被提升。下面这段程序中的变量标识符 foo() 被提升并分配给所在作用域（在这里是全局作用域）， 因此 foo() 不会导致 ReferenceError。 但是 foo 此时并没有赋值（如果它是一个函数声明而不是函数表达式， 那么就会赋值）。 foo() 由于对 undefined 值进行函数调用而导致非法操作， 因此抛出 TypeError 异常。  

```js
foo(); // not ReferenceError, but TypeError!

var foo = function bar() {
	// ...
};
```

同时也要记住， 即使是具名的函数表达式， 名称标识符在赋值之前也无法在所在作用域中使用。

```javascript
foo(); // TypeError
bar(); // ReferenceError
var foo = function bar() {
	// ...
};

//  上面一段代码相当于
/*var foo;
foo(); 
bar(); 
foo = function() {
	var bar = ...self...
	// ...
}*/
```

### 4.3 函数优先

函数声明和变量声明都会被提升。 但是一个值得注意的细节（这个细节可以出现在有多个“重复” 声明的代码中） 是函数会首先被提升， 然后才是变量。

一个普通块内部的函数声明通常会被提升到所在作用域的顶部。这个过程不会像下面的代码暗示的那样可以被条件判断所控制。但是需要注意这个行为并不可靠， 在 JavaScript 未来的版本中有可能发生改变， 因此应该 尽可能避免在块内部声明函数。  

```js
foo(); // "b"

var a = true;
if (a) {
   function foo() { console.log( "a" ); }
}
else {
   function foo() { console.log( "b" ); }
}
```

## 第5章 作用域闭包

### 5.1 启示

闭包是基于词法作用域书写代码时所产生的自然结果， 你甚至不需要为了利用它们而有意识地创建闭包。闭包的创建和使用在你的代码中随处可见。 你缺少的是根据你自己的意愿来识别、拥抱和影响闭包的思维环境。  

### 5.2 实质问题

当函数可以记住并访问所在的词法作用域时，就产生了闭包， 即使函数是在当前词法作用域之外执行。  

无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用， 无论在何处执行这个函数都会使用闭包。  

### 5.3 现在我懂了

本质上无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。 在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中， 只要使用了回调函数， 实际上就是在使用闭包！  

尽管 IIFE 本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建可以被封闭起来的闭包的工具。因此 IIFE 的确同闭包息息相关，即使本身并不会真的使用闭包。  

### 5.4 循环和闭包

延迟函数的回调会在循环结束时才执行。 事实上，当定时器运行时即使每个迭代中执行的是 setTimeout(.., 0)，所有的回调函数依然是在循环结束后才会被执行。

在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部， 每个迭代中都会含有一个具有正确值的变量供我们访问。  

我们使用 IIFE 在每次迭代时都创建一个新的作用域。 换句话说， 每次迭代我们都需要一个块作用域。 

利用 let 声明， 可以用来劫持块作用域， 并且在这个块作用域中声明一个变量。 本质上这是将一个块转换成一个可以被关闭的作用域。  

### 5.5 模块

最常见的实现模块模式的方法通常被称为模块暴露。

模块模式需要具备两个必要条件。  

- 必须有外部的封闭函数， 该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。 
- 封闭函数必须返回至少一个内部函数， 这样内部函数才能在私有作用域中形成闭包， 并且可以访问或者修改私有的状态。  

一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看， 一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。  

当只需要一个实例时，可以对这个模式进行简单的改进来实现单例模式。我们将模块函数转换成了 IIFE，立即调用这个函数并将返回值直接赋值给单例的模块实例标识符 foo。  

```javascript
var foo = (function CoolModule() {
	var something = "cool";
	var another = [1, 2, 3];

	function doSomething() {
		console.log( something );
	}

	function doAnother() {
		console.log( another.join( " ! " ) );
	}

	return {
		doSomething: doSomething,
		doAnother: doAnother
	};
})();

foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
```

模块也是普通的函数， 因此可以接受参数。

模块模式另一个简单但强大的变化用法是， 命名将要作为公共 API 返回的对象。通过在模块实例的内部保留对公共 API 对象的内部引用， 可以从内部对模块实例进行修改， 包括添加或删除方法和属性， 以及修改它们的值。

大多数模块依赖加载器 / 管理器本质上都是将这种模块定义封装进一个友好的 API。最重要的是要理解模块管理器没有任何特殊的“魔力”。 它们符合前面列出的模块模式的两个特点： 为函数定义引入包装函数， 并保证它的返回值和模块的 API 保持一致。 换句话说， 模块就是模块， 即使在它们外层加上一个友好的包装工具也不会发生任何变化。

ES6 中为模块增加了一级语法支持。 但通过模块系统进行加载时， ES6 会将文件当作独立的模块来处理。 每个模块都可以导入其他模块或特定的 API 成员， 同样也可以导出自己的 API 成员。  

基于函数的模块并不是一个能被稳定识别的模式（编译器无法识别）， 它们 的 API 语义只有在运行时才会被考虑进来。 因此可以在运行时修改一个模块 的 API 。相比之下， ES6 模块 API 更加稳定（API 不会在运行时改变）。 由于编辑器知 道这一点， 因此可以在（的确也这样做了） 编译期检查对导入模块的 API 成员的引用是否真实存在。 如果 API 引用并不存在， 编译器会在运行时抛出一 个或多个“早期” 错误， 而不会像往常一样在运行期采用动态的解决方案。  

ES6 的模块没有“行内” 格式， 必须被定义在独立的文件中（一个文件一个模块）。 浏览器或引擎有一个默认的“模块加载器”（可以被重载， 但这远超出了我们的讨论范围） 可以在导入模块时异步地加载模块文件。    

import 可以将一个模块中的一个或多个 API 导入到当前作用域中， 并分别绑定在一个变量上。module 会将整个模块的 API 导入并绑定到一个变量上。 export 会将当前模块的一个标识符（变量、 函数） 导出为公共 API。 这些操作可以在模块定义中根据需要使用任意多次。模块文件中的内容会被当作好像包含在作用域闭包中一样来处理， 就和前面介绍的函数闭包模块一样。  

## 附录A 动态作用域

动态作用域并不关心函数和作用域是如何声明以及在何处声明的， 只关心它们从何处调用。 换句话说， 作用域链是基于调用栈的， 而不是代码中的作用域嵌套。 

需要明确的是， 事实上 JavaScript 并不具有动态作用域。 它只有词法作用域， 简单明了。 但是 this 机制某种程度上很像动态作用域。  

主要区别： 词法作用域是在写代码或者说定义时确定的， 而动态作用域是在运行时确定的，this也是如此。词法作用域关注函数在何处声明， 而动态作用域关注函数从何处调用。  

## 附录B 块作用域的替代方案

至少从 ES3 发布以来， JavaScript 中就有了块作用域， 而 with 和 catch 分句就是块作用域的两个小例子。 但随着 ES6 中引入了 let， 我们的代码终于有了创建完整、 不受约束的块作用域的能力。 块作用域在功能上和代码风格上都拥有很多激动人心的新特性。  

catch 分句具有块作用域， 因此它可以在 ES6 之前的环境中作为块作用域的替代方案。  

重点是工具可以将 ES6 的代码转换成能在 ES6 之前环境中运行的形式。 你可以使用块作用域来写代码， 并享受它带来的好处， 然后在构建时通过工具来对代码进行预处理， 使之可以在部署时正常工作。 事实上， 这是向 ES6 中的所有（好吧， 不是所有而是大部分） 功能迁移的首选方式： 在从 ES6 之前的环境向 ES6 过渡时， 使用代码转换工具来对 ES6 代码进行处理， 生成兼容 ES5 的代码。  

Google 维护着一个名为 Traceur 的项目， 该项目正是用来将 ES6 代码转换成兼容 ES6 之前 的环境（大部分是 ES5， 但不是全部）。 TC39 委员会依赖这个工具（也有其他工具） 来测 试他们指定的语义化相关的功能。  

同隐式地劫持一个已经存在的作用域不同， let 声明会创建一个显示的作用域并与其进行绑定。 显式作用域不仅更加突出， 在代码重构时也表现得更加健壮。 在语法上， 通过强制性地将所有变量声明提升到块的顶部来产生更简洁的代码。 这样更容易判断变量是否属于某个作用域。它被称作 let 作用域或 let 声明（对比前面的 let 定义）。这种模式同很多人在函数作用域中手动将 var 声明提升到函数顶部的方式很接近。 let 声明有意将变量声明放在块的顶部。但是这里有一个小问题， let 声明并不包含在 ES6 中。 官方的 Traceur 编译器也不接受这 种形式的代码。  

```javascript
let (a = 2) {
	console.log( a ); // 2
}

console.log( a ); // ReferenceError
```

## 附录C this词法

ES6 添加了一个特殊的语法形式用于函数声明， 叫作箭头函数。 这里称作“胖箭头” 的写法通常被当作单调乏味且冗长的 function 关键字的简写。  

函数丢失了同 this 之间的绑定。   

```javascript
var obj = {
	id: "awesome",
	cool: function coolFn() {
		console.log( this.id );
	}
};

var id = "not awesome";

obj.cool(); // awesome

setTimeout( obj.cool, 100 ); // not awesome
```

简单来说， 箭头函数在涉及 this 绑定时的行为和普通函数的行为完全不一致。 它放弃了所有普通 this 绑定的规则， 取而代之的是用当前的词法作用域覆盖了 this 本来的值。  

# 第二部分 this和对象原型

## 第1章 关于this

### 1.1 为什么要用this

this 提供了一种更优雅的方式来隐式“传递” 一个对象引用， 因此可以将 API 设计得更加简洁并且易于复用。  

### 1.2 误解

人们很容易把 this 理解成指向函数自身， 这个推断从英语的语法角度来说是说得通的。 那么为什么需要从函数内部引用函数自身呢？ 常见的原因是递归（从函数内部调用这个函 数） 或者可以写一个在第一次被调用后自己解除绑定的事件处理器。  

如果要从函数对象内部引用它自身， 那只使用 this 是不够的。 一般来说你需要通过一个指 向函数对象的词法标识符（变量） 来引用它。  

第二种常见的误解是， this 指向函数的作用域。 这个问题有点复杂， 因为在某种情况下它是正确的， 但是在其他情况下它却是错误的。  

需要明确的是， this 在任何情况下都不指向函数的词法作用域。 在 JavaScript 内部， 作用域确实和对象类似， 可见的标识符都是它的属性。 但是作用域“对象” 无法通过 JavaScript 代码访问， 它存在于 JavaScript 引擎内部。  

### 1.3 this到底是什么

this 是在运行时进行绑定的， 并不是在编写时绑定， 它的上下文取决于函数调用时的各种条件。 this 的绑定和函数声明的位置没有任何关系， 只取决于函数的调用方式。 

当一个函数被调用时， 会创建一个活动记录（有时候也称为执行上下文）。 这个记录会包含函数在哪里被调用（调用栈）、 函数的调用方法、 传入的参数等信息。 this 就是记录的其中一个属性， 会在函数执行的过程中用到。  

## 第2章 this全面解析

### 2.1 调用位置

调用位置就是函数在代码中被调用的位置（而不是声明的位置）。通常来说， 寻找调用位置就是寻找“函数被调用的位置”， 但是做起来并没有这么简单， 因为某些编程模式可能会隐藏真正的调用位置。最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。我们关心的调用位置就在当前正在执行的函数的前一个调用中。  

### 2.2 绑定规则

如果要判断一个运行中函数的 this 绑定， 就需要找到这个函数的直接调用位置。找到之后 就可以顺序应用下面这四条规则来判断 this 的绑定对象。

- 由 new 调用绑定到新创建的对象。
- 由 call 或者 apply（或者 bind） 调用绑定到指定的对象。 
- 由上下文对象调用绑定到那个上下文对象。 
- 默认： 在严格模式下绑定到 undefined， 否则绑定到全局对象。  

第一种绑定方式是默认绑定。

首先要介绍的是最常用的函数调用类型： 独立函数调用。 可以把这条规则看作是无法应用其他规则时的默认规则。函数调用时应用了 this 的默认绑定， 因此 this 指向全局对象。如果使用严格模式（strict mode），那么全局对象将无法使用默认绑定， 因此 this 会绑定到 undefined  。

第二种绑定方式是隐式绑定。

另一条需要考虑的规则是调用位置是否有上下文对象， 或者说是否被某个对象拥有或者包含。当函数引用有上下文对象时， 隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。对象属性引用链中只有最顶层或者说最后一层会影响调用位置。  

```javascript
function foo() { 
    console.log( this.a ); 
} 

var obj2 = { 
    a: 42, 
    foo: foo 
};

var obj1 = { 
    a: 2, 
    obj2: obj2 
}; 

obj1.obj2.foo(); // 42  
```

一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象， 也就是说它会应用默认绑定， 从而把 this 绑定到全局对象或者 undefined 上， 取决于是否是严格模式。

```javascript
function foo() { console.log( this.a ); } 
var obj = { a: 2, foo: foo }; 
var bar = obj.foo; // 函数别名！ 
var a = "oops, global"; // a 是全局对象的属性 
bar(); // "oops, global" 
//  引用的是 foo 函数本身， 此时的bar() 是一个不带任何修饰的函数调用， 因此应用了默认绑定。
```

一种更微妙、 更常见并且更出乎意料的情况发生在传入回调函数时。

```javascript
function foo() { console.log( this.a ); } 
var obj = { a: 2, foo: foo }; 
var a = "oops, global"; // a 是全局对象的属性 
setTimeout( obj.foo, 100 ); // "oops, global" 
function setTimeout(fn,delay) { 
    // 等待 delay 毫秒 
    fn(); // <-- 调用位置！ 
}  
```

第三种绑定规则就是显式绑定。

JavaScript 提供的绝大多数函数以及自己创建的所有函数都可以使用 call(..) 和 apply(..) 方法。它们的第一个参数是一个对象， 它们会把这个对象绑定到 this ， 接着在调用函数时指定这个 this。 因为你可以直接指定 this 的绑定对象， 因此我们称之为显式绑定。  

如果你传入了一个原始值（字符串类型、 布尔类型或者数字类型） 来当作 this 的绑定对 象， 这个原始值会被转换成它的对象形式（也就是 new String(..)、 new Boolean(..) 或者 new Number(..)）。 这通常被称为“装箱”。  

一种在函数内部手动调用call()方法的强制绑定， 因此我们称之为硬绑定。硬绑定的典型应用场景就是创建一个包裹函数， 传入所有的参数并返回接收到的所有值。

```javascript
function foo(something) { 
    console.log( this.a, something ); 
    return this.a + something; 
} 
var obj = { a:2 }; 
var bar = function() { 
    return foo.apply( obj, arguments ); 
}; //  硬绑定
var b = bar( 3 ); // 2 3 
console.log( b ); // 5
```

  另一种使用方法是创建一个 i 可以重复使用的辅助函数： 

```javascript
function foo(something) { 
    console.log( this.a, something ); 
    return this.a + something; 
} 
function bind(fn, obj) { 
    return function() { 
        return fn.apply( obj, arguments ); 
    }; 
} // 简单的辅助绑定函数 
var obj = { a:2 }; 
var bar = bind( foo, obj ); 
var b = bar( 3 ); // 2 3 
console.log( b ); // 5  
```

由于硬绑定是一种非常常用的模式， 所以在 ES5 中提供了内置的方法 Function.prototype. bind ，bind(..) 会返回一个硬编码的新函数， 它会把参数设置为 this 的上下文并调用原始函数。  

第三方库的许多函数， 以及 JavaScript 语言和宿主环境中许多新的内置函数， 都提供了一 个可选的参数， 通常被称为“上下文”（context）， 其作用和 bind(..) 一样， 确保你的回调函数使用指定的 this。这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定， 这样你可以少些一些代码。  

```javascript
function foo(el) { 
    console.log( el, this.id ); 
} 
var obj = { id: "awesome" }; // 调用 foo(..) 时把 this 绑定到 obj 
[1, 2, 3].forEach( foo, obj ); // 1 awesome 2 awesome 3 awesome  
```

第四条也是最后一条 this 的绑定规则是 new 绑定。

首先我们重新定义一下 JavaScript 中的“构造函数”。 在 JavaScript 中， 构造函数只是一些 使用 new 操作符时被调用的函数。 它们并不会属于某个类， 也不会实例化一个类。 实际上， 它们甚至都不能说是一种特殊的函数类型， 它们只是被 new 操作符调用的普通函数而已。  

使用 new 来调用函数， 或者说发生构造函数调用时， 会自动执行下面的操作。 

- 创建（或者说构造） 一个全新的对象。 
- 这个新对象会被执行 [[ 原型 ]] 连接。 
- 这个新对象会绑定到函数调用的 this。 
- 如果函数没有返回其他对象， 那么 new 表达式中的函数调用会自动返回这个新对象。  

```javascript
function foo(a) { 
    this.a = a; 
} 
var bar = new foo(2); 
console.log( bar.a ); // 2  
```

### 2.3 优先级

显式绑定优先级更高， 也就是说在判断时应当先考虑是否可以应用显式绑定。  

new 绑定比隐式绑定优先级高。  

在 new 中使用硬绑定函数， 主要目的是预先设置函数的一些参数， 这样在使用 new 进行初始化时就可以只传入其余的参数。 bind(..) 的功能之一就是可以把除了第一个参数（第一个参数用于绑定 this） 之外的其他参数都传给下层的函数（这种技术称为“部分应用”， 是“柯里化” 的一种）。

```javascript
function foo(p1,p2) { this.val = p1 + p2; } 
// 之所以使用 null 是因为在本例中我们并不关心硬绑定的 this 是什么 
// 反正使用 new 时 this 会被修改 
var bar = foo.bind( null, "p1" ); 
var baz = new bar( "p2" ); 
baz.val; // p1p2  
```

现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。 可以按照下面的顺序来进行判断： 

- 函数是否在 new 中调用（new 绑定），如果是的话 this 绑定的是新创建的对象。 `var bar = new foo()` 
- 函数是否通过 call、 apply（显式绑定） 或者硬绑定调用，如果是的话， this 绑定的是指定的对象。 `var bar = foo.call(obj2)` 
- 函数是否在某个上下文对象中调用（隐式绑定）， 如果是的话， this 绑定的是那个上 下文对象。 `var bar = obj1.foo()` 
- 如果都不是的话， 使用默认绑定。 如果在严格模式下， 就绑定到 undefined， 否则绑定到 全局对象。 `var bar = foo()`  

### 2.4 绑定例外

如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、 apply 或者 bind， 这些值 在调用时会被忽略， 实际应用的是默认绑定规则。那么什么情况下你会传入 null 呢？ 一种非常常见的做法是使用 apply(..) 来“展开” 一个数组， 并当作参数传入一个函数。 类似地， bind(..) 可以对参数进行柯里化（预先设置一些参数）， 这种方法有时非常有用。

```javascript
function foo(a,b) { console.log( "a:" + a + ", b:" + b ); } // 把数组“展开” 成参数 
foo.apply( null, [2, 3] ); // a:2, b:3 

// 使用 bind(..) 进行柯里化 
var bar = foo.bind( null, 2 ); 
bar( 3 ); // a:2, b:3  
```

一种“更安全” 的做法是传入一个特殊的对象， 把 this 绑定到这个对象不会对你的程序产生任何副作用。  

```javascript
function foo(a,b) { console.log( "a:" + a + ", b:" + b ); } 
// 我们的 DMZ 空对象 
var ø = Object.create( null ); 
// 把数组展开成参数 
foo.apply( ø, [2, 3] ); // a:2, b:3 
// 使用 bind(..) 进行柯里化 
var bar = foo.bind( ø, 2 ); 
bar( 3 ); // a:2, b:3  
```

另一个需要注意的是， 你有可能（有意或者无意地） 创建一个函数的“间接引用”， 在这种情况下， 调用这个函数会应用默认绑定规则。 间接引用最容易在赋值时发生。

```javascript
function foo() { console.log( this.a ); } 
var a = 2; 
var o = { a: 3, foo: foo }; 
var p = { a: 4 }; 
o.foo(); // 3 
(p.foo = o.foo)(); // 2  
// 赋值表达式 p.foo = o.foo 的返回值是目标函数的引用， 因此调用位置是 foo() 
// 而不是 p.foo() 或者 o.foo()。因此会应用默认绑定
// 如果函数体处于严格模式， this 会被绑定到 undefined， 否则 this 会被绑定到全局对象。
```

硬绑定会大大降低函数的灵活性， 使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。 如果可以给默认绑定指定一个全局对象和 undefined 以外的值， 那就可以实现和硬绑定相同的效果， 同时保留隐式绑定或者显式绑定修改 this 的能力。 可以通过一种被称为软绑定的方法来实现我们想要的效果。

除了软绑定之外， softBind(..) 的其他原理和 ES5 内置的 bind(..) 类似。 它会对指定的函数进行封装， 首先检查调用时的 this， 如果 this 绑定到全局对象或者 undefined， 那就把 指定的默认对象 obj 绑定到 this， 否则不会修改 this。 此外， 这段代码还支持可选的柯里化。

```javascript
function foo() { console.log("name: " + this.name); } 
var obj = { name: "obj" }, 
    obj2 = { name: "obj2" }, 
    obj3 = { name: "obj3" }; 
var fooOBJ = foo.softBind( obj ); 
fooOBJ(); // name: obj 
obj2.foo = foo.softBind(obj); 
obj2.foo(); // name: obj2 
fooOBJ.call( obj3 ); // name: obj3 
setTimeout( obj2.foo, 10 ); // name: obj 
// 可以看到， 软绑定版本的 foo() 可以手动将 this 绑定到 obj2 或者 obj3 上， 
// 但如果应用默认绑定， 则会将 this 绑定到 obj。
```

### 2.5 this词法

ES6 中介绍了一种无法使用 这些规则的特殊函数类型： 箭头函数。  箭头函数并不是使用 function 关键字定义的， 而是使用被称为“胖箭头” 的操作符 `=>` 定 义的。 箭头函数不使用 this 的四种标准规则， 而是根据外层（函数或者全局） 作用域来决定 this。  

```javascript
function foo() { // 返回一个箭头函数 
    return (a) => { //this 继承自 foo() 
        console.log( this.a ); }; 
} 
var obj1 = { a:2 }; 
var obj2 = { a:3  }; 
var bar = foo.call( obj1 ); 
bar.call( obj2 ); // 2, 不是 3 ！  
// foo() 内部创建的箭头函数会捕获调用时 foo() 的 this。 
// 由于 foo() 的 this 绑定到 obj1，bar（引用箭头函数） 的 this 也会绑定到 obj1， 
// 箭头函数的绑定无法被修改。（new 也不行！ ）
```

箭头函数最常用于回调函数中， 例如事件处理器或者定时器。箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象， 此外， 其重要性还体现在它用更常见的词法作用域取代了传统的 this 机制。

实际上， 在 ES6 之前我们就已经在使用一种几乎和箭头函数完全一样的模式。虽然 self = this 和箭头函数看起来都可以取代 bind(..)， 但是从本质上来说， 它们想替代的是 this 机制。  

## 第3章 对象

### 3.1 语法

对象可以通过两种形式定义： 声明（文字） 形式和构造形式。构造形式和文字形式生成的对象是一样的。 唯一的区别是， 在文字声明中你可以添加多个 键 / 值对， 但是在构造形式中你必须逐个添加属性。    

```javascript
// 对象的文字语法大概是这样： 
var myObj = { 
    key: value 
    // ... 
}; 

// 构造形式大概是这样： 
var myObj = new Object(); 
myObj.key = value;  
```

### 3.2 类型

对象是 JavaScript 的基础。 在 JavaScript 中一共有六种主要类型（术语是“语言类型”）  

• string • number • boolean • null • undefined • object  

注意， 简单基本类型（string、number、boolean 、null 和 undefined） 本身并不是对象。 null 有时会被当作一种对象类型， 但是这其实只是语言本身的一个 bug， 即对 null 执行 typeof null 时会返回字符串 "object"。 实际上， null 本身是基本类型。有一种常见的错误说法是“JavaScript 中万物皆是对象”， 这显然是错误的。  

> 原理是这样的， 不同的对象在底层都表示为二进制， 在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型， null 的二进制表示是全 0， 自然前三位也是 0， 所以执行 typeof 时会返回“object”。  

实际上， JavaScript 中有许多特殊的对象子类型， 我们可以称之为复杂基本类型。 函数就是对象的一个子类型（从技术角度来说就是“可调用的对象”）。 JavaScript 中的函数是“一等公民”， 因为它们本质上和普通的对象一样（只是可以调用）， 所以可以像操作其他对象一样操作函数（比如当作另一个函数的参数）。 数组也是对象的一种类型， 具备一些额外的行为。 数组中内容的组织方式比一般的对象要稍微复杂一些。  

JavaScript 中还有一些对象子类型， 通常被称为内置对象。 有些内置对象的名字看起来和简单基础类型一样， 不过实际上它们的关系更复杂。

• String • Number • Boolean • Object • Function • Array • Date • RegExp • Error  

> 字符串字面量、数字字面量等能自动将其转换为对应的对象，并不需要显式创建一个对象，就能直接访问该对象的属性或者方法  。null 和 undefined 没有对应的构造形式， 它们只有文字形式。 相反， Date 只有构造， 没有文字形式。  
>
> 对于 Object、 Array、 Function 和 RegExp（正则表达式） 来说， 无论使用文字形式还是构造形式， 它们都是对象， 不是字面量。 
>
> 在某些情况下， 相比用文字形式创建对象， 构造形 式可以提供一些额外选项。 由于这两种形式都可以创建对象， 所以我们首选更简单的文字形式。 建议只在需要那些额外选项时使用构造形式。 
>
> Error 对象很少在代码中显式创建， 一般是在抛出异常时被自动创建。 也可以使用 new Error(..) 这种构造形式来创建， 不过一般来说用不着。  

### 3.3 内容

对象的内容是由一些存储在特定命名位置的（任意类型的） 值组成的， 我们称之为属性。 

当我们说“内容” 时， 似乎在暗示这些值实际上被存储在对象内部， 但是这只是它的表现形式。 在引擎内部， 这些值的存储方式是多种多样的， 一般并不会存在对象容器内部。 存储在对象容器内部的是这些属性的名称， 它们就像指针（从技术角度来说就是引用） 一样， 指向这些值真正的存储位置。   

如果要访问 myObject 中 a 位置上的值， 我们需要使用 `.` 操作符或者 `[]` 操作符。

> `.a` 语法通常被称为“属性访问”， 
>
> `["a"]` 语法通常被称为“键访问”。
>
> 这两种语法的主要区别在于 . 操作符要求属性名满足标识符的命名规范， 而 [".."] 语法 可以接受任意 UTF-8/Unicode 字符串作为属性名。 举例来说， 如果要引用名称为 "Super-Fun!" 的属性， 那就必须使用 ["Super-Fun!"] 语法访问， 因为 Super-Fun! 并不是一个有效的标识符属性名。  
>
> 此外， 由于 [".."] 语法使用字符串来访问属性， 所以可以在程序中构造这个字符串，即利用其它变量代替。另外，在对象中， 属性名永远都是字符串。 如果你使用 string（字面量） 以外的其他值作为属性名， 那它首先会被转换为一个字符串。   

可计算属性名。ES6 增加了可计算属性名， 可以在文字形式中使用 `[]` 包裹一个表达式来当作属性名。

```javascript
var prefix = "foo";
var myObject = {
  [prefix + "bar"]:"hello",
  [prefix + "baz"]: "world"
};
myObject["foobar"]; // hello
myObject["foobaz"]; // world
```

属性和方法。无论返回值是什么类型， 每次访问对象的属性就是属性访问。 如果属性访问返回的是一个函数， 那它也并不是一个“方法”。 属性访问返回的函数和其他函数没有任何区别（除了可能发生的隐式绑定 this)。

数组。数组也支持 [] 访问形式， 同时数组有一套更加结构化的值存储机制（不过仍然不限制值的类型）。 数组期望的是数值下标， 也就是说值存储的位置（通常被称为索引） 是整数。一般可以只用对象来存储键 / 值对， 只用数组来存储数值下标 / 值对。  

复制对象。对于 JSON 安全（也就是说可以被序列化为一个 JSON 字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象） 的对象来说， 有一种巧妙的复制方法： var newObj = JSON.parse( JSON.stringify( someObj ) ); 当然， 这种方法需要保证对象是 JSON 安全的， 所以只适用于部分情况。相比深复制， 浅复制非常易懂并且问题要少得多， 所以 ES6 定义了 Object.assign(..) 方 法来实现浅复制。 Object.assign(..) 方法的第一个参数是目标对象， 之后还可以跟一个或多个源对象。 它会遍历一个或多个源对象的所有可枚举的自有键（owned key） 并把它们复制（使用 = 操作符赋值） 到目标对象， 最后返回目标对象。

```javascript
var newObj = Object.assign( {}, myObject );
newObj.a;						// 2
newObj.b === anotherObject;		// true
newObj.c === anotherArray;		// true
newObj.d === anotherFunction;	// true
```



属性描述符。在 ES5 之前， JavaScript 语言本身并没有提供可以直接检测属性特性的方法， 比如判断属性是否是只读。  但是从 ES5 开始， 所有的属性都具备了属性描述符。在创建普通属性时属性描述符会使用默认值， 我们也可以使用 Object.defineProperty(..) 来添加一个新属性或者修改一个已有属性（如果它是 configurable） 并对特性进行设置。  

- writable 决定是否可以修改属性的值。  
- Configurable  只要属性是可配置的， 就可以使用 defineProperty(..) 方法来修改属性描述符。把 configurable 修改成 false 是单向操作， 无法撤销。
- Enumerable  这个描述符控制的是属性是否会出现在对象的属性枚举中。

```javascript
var myObject = {};

Object.defineProperty( myObject, "a", {
	value: 2,
	writable: true,
	configurable: true,
	enumerable: true
} );

myObject.a; // 2
```

不可变性。对象常量，结合 writable:false 和 configurable:false 就可以创建一个真正的常量属性（不可修改、 重定义或者删除）。禁止扩展，如果你想禁止一个对象添加新属性并且保留已有属性，可以使用Object.preventExtensions(..)。密封，Object.seal(..) 会创建一个“密封” 的对象， 这个方法实际上会在一个现有对象上调用 Object.preventExtensions(..) 并把所有现有属性标记为 configurable:false。所以， 密封之后不仅不能添加新属性， 也不能重新配置或者删除任何现有属性（虽然可以修改属性的值）。冻结，Object.freeze(..) 会创建一个冻结对象， 这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有“数据访问” 属性标记为 writable:false， 这样就无法修改它们的值。  

Getter和Setter 。在 ES5 中可以使用 getter 和 setter 部分改写默认操作， 但是只能应用在单个属性上， 无法应用在整个对象上。 getter 是一个隐藏函数， 会在获取属性值时调用。 setter 也是一个隐藏函数， 会在设置属性值时调用。  

存在性。in 操作符会检查属性是否在对象及其 [[Prototype]] 原型链中。 相比之下， hasOwnProperty(..) 只会检查属性是否在 myObject 对象中， 不会检查 [[Prototype]] 链。  

### 3.4 遍历

for..in 循环可以用来遍历对象的可枚举属性列表（包括 [[Prototype]] 链）。  

对于数值索引的数组来说， 可以使用标准的 for 循环来遍历值。这实际上并不是在遍历值， 而是遍历下标来指向值， 如 myArray[i]。  

ES5 中增加了一些数组的辅助迭代器， 包括 forEach(..)、 every(..) 和 some(..)。 每种辅 助迭代器都可以接受一个回调函数并把它应用到数组的每个元素上， 唯一的区别就是它们对于回调函数返回值的处理方式不同。  

- forEach(..) 会遍历数组中的所有值并忽略回调函数的返回值。 
- every(..) 会一直运行直到回调函数返回 false。
- some(..) 会一直运行直到回调函数返回 true。  

every(..) 和 some(..) 中特殊的返回值和普通 for 循环中的 break 语句类似， 它们会提前终止遍历。 使用 for..in 遍历对象是无法直接获取属性值的， 因为它实际上遍历的是对象中的所有可枚举属性， 你需要手动获取属性值。  

ES6 增加了一种用来遍历数组的 for..of 循环语法，前提是对象本身定义了迭代器可以遍历对象） ，可以直接遍历值而不是数组下标或者对象属性。for..of 循环首先会向被访问对象请求一个迭代器对象， 然后通过调用迭代器对象的 next() 方法来遍历所有返回值。  



## 第4章 混合对象“类”

### 4.1 类理论

面向对象编程强调的是数据和操作数据的行为本质上是互相关联的（当然， 不同的数据有不同的行为）， 因此好的设计就是把数据以及和它相关的行为打包（或者说封装） 起来。 这在正式的计算机科学中有时被称为数据结构。  

由于类是一种设计模式， 所以你可以用一些方法近似实现类的功能。 为了满足对于类设计模式的最普遍需求， JavaScript 提供了一些近似类的语法。  

### 4.2 类的机制

在许多面向类的语言中， “标准库” 会提供 Stack 类， 它是一种“栈” 数据结构（支持压入、 弹出， 等等）。 Stack 类内部会有一些变量来存储数据， 同时会提供一些公有的可访问行为（“方法”）， 从而让你的代码可以和（隐藏的） 数据进行交互（比如添加、 删除数据）。但是在这些语言中， 你实际上并不是直接操作 Stack  ，Stack 类仅仅是一个抽象的表示， 它描述了所有“栈” 需要做的事， 但是它本身并不是一个“栈”。 你必须先实例化 Stack 类然后才能对它进行操作。

类实例是由一个特殊的类方法构造的， 这个方法名通常和类名相同， 被称为构造函数。 这个方法的任务就是初始化实例需要的所有信息（状态）。类构造函数属于类， 而且通常和类同名，同时构造函数大多需要用 new 来调， 这样语言引擎才知道你想要构造一个新的类实例。  

### 4.3 类的继承

在面向类的语言中， 你可以先定义一个类， 然后定义一个继承前者的类。 后者通常被称为“子类”， 前者通常被称为“父类”。   

多态是一个非常广泛的话题， 我们现在所说的“相对” 只是多态的一个方面： 任何方法都 可以引用继承层次中高层的方法（无论高层的方法名和当前方法名是否相同）。 之所以说 “相对” 是因为我们并不会定义想要访问的绝对继承层次（或者说类）， 而是使用相对引用 “查找上一层”。  

有些面向类的语言允许你继承多个“父类”。 多重继承意味着所有父类的定义都会被复制到子类中。  相比之下， JavaScript 要简单得多： 它本身并不提供“多重继承” 功能。  

### 4.4 混入

在继承或者实例化时， JavaScript 的对象机制并不会自动执行复制行为。 简单来说， JavaScript 中只有对象， 并不存在可以被实例化的“类”。 一个对象并不会被复制到其他对 象， 它们会被关联起来。由于在其他语言中类表现出来的都是复制行为， 因此 JavaScript 开发者也想出了一个方法来模拟类的复制行为， 这个方法就是混入。 接下来我们会看到两种类型的混入： 显式和隐式。  

技术角度来说， 函数实际上没有被复制， 复制的是函数引用。   

在 JavaScript 中（由于屏蔽） 使用显式伪多态会在所有需要使用（伪） 多态引用的地 方创建一个函数关联， 这会极大地增加维护成本。 此外， 由于显式伪多态可以模拟多重继承， 所以它会进一步增加代码的复杂度和维护难度。 

JavaScript 中的函数无法（用标准、 可靠的方法） 真正地复制， 所以你只能复制对共享函数对象的引用。

显式混入模式的一种变体被称为“寄生继承”， 它既是显式的又是隐式的， 主要推广者是 Douglas Crockford 。  

```javascript
// "Traditional JS Class" `Vehicle`
function Vehicle() {
	this.engines = 1;
}
Vehicle.prototype.ignition = function() {
	console.log( "Turning on my engine." );
};
Vehicle.prototype.drive = function() {
	this.ignition();
	console.log( "Steering and moving forward!" );
};

// "Parasitic Class" `Car`
function Car() {
	// first, `car` is a `Vehicle`
	var car = new Vehicle();

	// now, let's modify our `car` to specialize it
	car.wheels = 4;

	// save a privileged reference to `Vehicle::drive()`
	var vehDrive = car.drive;

	// override `Vehicle::drive()`
	car.drive = function() {
		vehDrive.call( this );
		console.log( "Rolling on all " + this.wheels + " wheels!" );
	};

	return car;
}

var myCar = new Car();

myCar.drive();
// Turning on my engine.
// Steering and moving forward!
// Rolling on all 4 wheels!
```



隐式混入模式。例如，通过在构造函数调用或者方法调用中使用 Something.cool.call( this )， 我们实际上“借 用” 了函数 Something.cool() 并在 Another 的上下文中调用了它。 最终的结果是 Something.cool() 中的赋值操作都会应用在 Another 对象上而不是 Something 对象上。  

## 第5章 原型

### 5.1 [[Prototype]]  

JavaScript 中的对象有一个特殊的 [[Prototype]] 内置属性， 其实就是对于其他对象的引用。 几乎所有的对象在创建时 [[Prototype]] 属性都会被赋予一个非空的值。

对于默认的 [[Get]] 操作来说， 如果无法在对象本身找到需要的属性， 就会继续访问对象 的 [[Prototype]] 链。这个过程一直持续到找到匹配的属性名，或者[[Prototype]]链结束。如果在链的末尾没有找到匹配的属性，则[[GET] ]操作的返回结果是 undefined 的。

使用 for..in 遍历对象时原理和查找 [[Prototype]] 链类似， 任何可以通过原型链访问到的属性都会被枚举（属性enumerable 是可枚举的）。 使用 in 操作符来检查属性在对象中是否存在时， 同样会查找对象的整条原型链（无论属性enumerable 是否可枚举）。 

所有普通的 [[Prototype]] 链最终都会指向内置的 Object.prototype。  

如果属性名 foo 既出现在 myObject 中也出现在 myObject 的 [[Prototype]] 链上层， 那 么就会发生屏蔽。 myObject 中包含的 foo 属性会屏蔽原型链上层的所有 foo 属性， 因为 myObject.foo 总是会选择原型链中最底层的 foo 属性。  

如果你希望在特殊情况下也屏蔽 foo， 那就不能使用 = 操作符来赋值， 而是使 用 Object.defineProperty(..) 来向 myObject 添加 foo。  如果需要对屏蔽方法进行委托的话就不得不使用丑陋的显式伪多态。有些情况下会隐式产生屏蔽。

### 5.2 “类”   

实际上， JavaScript 才是真正应该被称为“面向对象” 的语言， 因为它是少有的可以不通过类， 直接创建对象的语言。JavaScript 中只有对象。  

在 JavaScript 中， 并没有类似的复制机制。 你不能创建一个类的多个实例， 只能创建多个对象， 它们 [[Prototype]] 关联的是同一个对象。 但是在默认情况下并不会进行复制， 因此这些对象之间并不会完全失去联系， 它们是互相关联的。new Foo() 会生成一个新对象（我们称之为 a）， 这个新对象的内部链接 [[Prototype]] 关联的是 Foo.prototype 对象。  

继承意味着复制操作， JavaScript（默认） 并不会复制对象属性。 相反， JavaScript 会在两 个对象之间创建一个关联， 这样一个对象就可以通过委托访问另一个对象的属性和函数。 委托这个术语可以更加准确地描述 JavaScript 中对象的关联机制。    

换句话说， 在 JavaScript 中对于“构造函数” 最准确的解释是， 所有带 new 的函数调用。 函数不是构造函数， 但是当且仅当使用 new 时， 函数调用会变成“构造函数调用”。  

一些随意的对象属性引用， 比如 a1.constructor， 实际上是不被信任的， 它们不一 定会指向默认的函数引用。Foo.prototype 的 .constructor 属性只是 Foo 函数在声明时的默认属性。 如果你创建了一个新对象并替换了函数默认的 .prototype 对象引用， 那么新对象并不会自动获 得 .constructor 属性。  

### 5.3 （原型） 继承  

调用 Object.create(..) 会凭空创建一个“新” 对象并把新对象内部的 [[Prototype]] 关联到你指定的对象（本例中是 Foo.prototype）。 换句话说， 这条语句的意思是： “ 创建一个新的 Bar.prototype 对象并把它关联到 Foo. prototype”。

声明 function Bar() { .. } 时， 和其他函数一样， Bar 会有一个 .prototype 关联到默认的对象， 但是这个对象并不是我们想要的 Foo.prototype。 因此我们创建了一个新对象并把它关联到我们希望的对象上， 直接把原始的关联对象抛弃掉。

Bar.prototype = Foo.prototype 并不会创建一个关联到 Bar.prototype 的新对象， 它只 是让 Bar.prototype 直接引用 Foo.prototype 对象。 因此当你执行类似 Bar.prototype. myLabel = ... 的赋值语句时会直接修改 Foo.prototype 对象本身。  

Bar.prototype = new Foo() 的确会创建一个关联到 Bar.prototype 的新对象。 但是它使用 了 Foo(..) 的“构造函数调用”， 如果函数 Foo 有一些副作用（比如写日志、 修改状态、 注册到其他对象、 给 this 添加数据属性， 等等） 的话， 就会影响到 Bar() 的“后代” 。

因此， 要创建一个合适的关联对象， 我们必须使用 Object.create(..) 而不是使用具有副作用的 Foo(..)。 这样做唯一的缺点就是需要创建一个新对象然后把旧对象抛弃掉， 不能 直接修改已有的默认对象。    

如果能有一个标准并且可靠的方法来修改对象的 [[Prototype]] 关联就好了。 在 ES6 之前， 我们只能通过设置 .__proto__ 属性来实现， 但是这个方法并不是标准并且无法兼容所有浏览器。 ES6 添加了辅助函数 Object.setPrototypeOf(..)， 可以用标准并且可靠的方法来修改关联。  

```javascript
// ES6 之前需要抛弃默认的 Bar.prototype
Bar.ptototype = Object.create( Foo.prototype );
// ES6 开始可以直接修改现有的 Bar.prototype
Object.setPrototypeOf( Bar.prototype, Foo.prototype );
```



在传统的面向类环境中，检查一个实例（JavaScript 中的对象） 的继承祖先（JavaScript 中的委托关联） 通常被称为内省（或者反射）。  

```javascript
function Foo() {
// ...
} 
Foo.prototype.blah = ...;
var a = new Foo();
a instanceof Foo; // true
```

第一种方法是站在“类” 的角度来判断，instanceof 操作符的左操作数是一个普通的对象， 右操作数是一个函数。 instanceof 回答 的问题是： 在 a 的整条 [[Prototype]] 链中是否有指向 Foo.prototype 的对象？可惜， 这个方法只能处理对象（a） 和函数（ 带 .prototype 引用的 Foo） 之间的关系。  

下面是第二种判断 [[Prototype]] 反射的方法， 它更加简洁： 

```javascript
Foo.prototype.isPrototypeOf( a ); // true 
```



注意， 在本例中， 我们实际上并不关心甚至不需要 Foo， 我们只需要一个可以用来判断的对象（本例中是 Foo.prototype） 就行。 isPrototypeOf(..) 回答的问题是： 在 a 的整条 [[Prototype]] 链中是否出现过 Foo.prototype ？

我们也可以直接获取一个对象的 [[Prototype]] 链。绝大多数浏览器也支持一种非标准的方法来访问内部 [[Prototype]] 属性。  

```javascript
Object.getPrototypeOf( a ); // 在 ES5 中标准的方法
Object.getPrototypeOf( a ) === Foo.prototype; // true 验证
a.__proto__ === Foo.prototype; // true 非标准的方法，使用.__proto__
```



和我们之前说过的 .constructor 一样， `.__proto__` 实际上并不存在于你正在使用的对象中 （本例中是 a）。 实际上， 它和其他的常用函数（.toString()、 .isPrototypeOf(..)， 等等）一样， 存在于内置的 Object.prototype 中。（它们是不可枚举的）。

### 5.4 对象关联  

[[Prototype]] 机制就是存在于对象中的一个内部链接， 它会引用其他对象。 通常来说， 这个链接的作用是： 如果在对象上没有找到需要的属性或者方法引用， 引擎就会继续在 [[Prototype]] 关联的对象上进行查找。 同理， 如果在后者中也没有找到需要的引用就会继续查找它的 [[Prototype]]， 以此类推。 这一系列对象的链接被称为“原型链”。 

Object.create(..) 会创建一个新对象并把它关联到我们指定的对象， 这样 我们就可以充分发挥 [[Prototype]] 机制的威力（委托） 并且避免不必要的麻烦（比如使用 new 的构造函数调用会生成 .prototype 和 .constructor 引用）。  

Object.create(..) 是在 ES5 中新增的函数， 所以在 ES5 之前的环境中（ 比如旧 IE） 如果要支持这个功能的话就需要使用一段简单的 polyfill 代码。

关联关系是备用。从内部来说， 我们的实现遵循的是委托设计模式。

```javascript
var anotherObject = {
	cool: function() {
		console.log( "cool!" );
	}
};

var myObject = Object.create( anotherObject );

myObject.doCool = function() {
	this.cool(); // internal delegation!
};

myObject.doCool(); // "cool!"
```



内部委托比起直接委托可以让 API 接口设计更加清晰。  

## 第6章 行为委托

### 6.1 面向委托的设计  

在 JavaScript 中， [[Prototype]] 机制会把对象关联到其他对象。委托行为意味着某些对象在找不到属性或者方法引用时会把这个请求委托给另一 个对象。 这是一种极其强大的设计模式， 和父类、 子类、 继承、 多态等概念完全不同。对象关联风格的代码还有一些不同之处。  

- 通常来说， 在 [[Prototype]] 委托中最好把状态保存在委托者而不是委托目标上。  
- 我们应尽量避免在 [[Prototype]] 链的不同级别中使用相同的命名，否则就需要使用笨拙并且脆弱的语法来消除引用歧义。
- 和委托者进行交互时可以使用委托目标中的通用方法，因为委托者委托了委托目标，同时 this 绑定在委托者身上。  

你无法在两个或两个以上互相（双向） 委托的对象之间创建循环委托。 如果你把 B 关联到 A 然后试着把 A 关联到 B， 就会出错。  

### 6.2 类与对象  

对象关联可以更好地支持关注分离（separation of concerns） 原则， 创建和初始化并不需要合并为一个步骤。  

### 6.3 更简洁的设计  

对象关联除了能让代码看起来更简洁（并且更具扩展性） 外还可以通过行为委托模式简化代码结构。   

### 6.4 更好的语法  

ES6 的 class 语法可以简洁地定义类方法， 这个特性让 class 乍看起来更有吸引力。在 ES6 中我们可以在任意对象的字面形式中使用简洁方法声明（concise method declaration）， 所以对象关联风格的对象可以这样声明（和 class 的语法糖一样）。唯一的区别是对象的字面形式仍然需要使用“,” 来分隔元素， 而 class 语法不需要。  

此外， 在 ES6 中， 你可以使用对象的字面形式（ 这样就可以使用简洁方法定义）来改写之前繁琐的属性赋值语 法（ 比 如 AuthController 的 定 义 ）， 然后用 Object. setPrototypeOf(..) 来修改它的 [[Prototype]] 。

```javascript
var LoginController = {
	errors: [],
	getUser() { // Look ma, no `function`!
		// ...
	},
	getPassword() {
		// ...
	}
	// ...
};

// NOW, link `AuthController` to delegate to `LoginController`
Object.setPrototypeOf( AuthController, LoginController );
```



由于函数对象本身没有名称标识符，所以 bar () 的缩写形式（function()..）实际上会变成一个匿名函数表达式并赋值给 bar 属性。相比之下，具名函数表达式（function baz ()..）会额外给 .baz 属性附加一个词法名称标识符 baz 。

```javascript
var Foo = {
	bar() { /*..*/ },
	baz: function baz() { /*..*/ }
};

// Here's the syntactic de-sugaring that expresses how that code will operate
var Foo = {
	bar: function() { /*..*/ },
	baz: function baz() { /*..*/ }
};
```



去掉语法糖的版本使用的是匿名函数表达式， 通常来说并不会在追踪栈中添加 name， 但是简洁方法很特殊， 会给对应的函数对象设置一个内部的 name 属性， 这样理论上可以用在追踪栈中。但是它们不具备可以自我引用的词法标识符。  

### 6.5 内省  

自省就是检查实例的类型。 类实例的自省主要目的是通过创建方式来判断对象的结构和功能。  

从语法角度来说， instanceof 似乎是检查 a1 和 Foo 的关系， 但是实际上它想说的是 a1 和 Foo.prototype（引用的对象） 是互相关联的。instanceof 语法会产生语义困惑而且非常不直观。 如果你想检查对象 a1 和某个对象的关 系， 那必须使用另一个引用该对象的函数才行——你不能直接判断两个对象是否关联。  

还有一种常见但是可能更加脆弱的内省模式，这种模式被称为“鸭子类型”。我们并没有检查 a1 和委托 something() 函数的对象之间的关系， 而是假设如果 a1 通过了 测试 a1.something 的话， 那 a1 就一定能调用 .something()（无论这个方法存在于 a1 自身 还是委托到其他对象）。ES6 的 Promise 就是典型的“鸭子类型”  。

现在回到本章想说的对象关联风格代码， 其内省更加简洁。 使用对象关联时， 所有的对象都是通过 [[Prototype]] 委托互相关联， 下面是内省的方法。

```javascript
var Foo = { /* .. */ };
var Bar = Object.create( Foo );
Bar...
var b1 = Object.create( Bar );

// relating `Foo` and `Bar` to each other
Foo.isPrototypeOf( Bar ); // true
Object.getPrototypeOf( Bar ) === Foo; // true

// relating `b1` to both `Foo` and `Bar`
Foo.isPrototypeOf( b1 ); // true
Bar.isPrototypeOf( b1 ); // true
Object.getPrototypeOf( b1 ) === Bar; // true

```



## 附录A ES6中的Class

除了语法更好看之外， ES6 还解决了什么问题呢？ 

- 不再引用杂乱的 .prototype 了。 
- Button 声明时直接“ 继承 ” 了 ，不 再 需 要 通 过 Object.create(..) 来 替 换 .prototype 对象， 也不需要设置 `.__proto__` 或者 Object.setPrototypeOf(..)。 
- 可以通过 super(..) 来实现相对多态， 这样任何方法都可以引用原型链上层的同名方法。 这可以解决第 4 章提到过的那个问题： 构造函数不属于类， 所以无法互相引用—— super() 可以完美解决构造函数的问题。
- class 字面语法不能声明属性（只能声明方法）。 看起来这是一种限制， 但是它会排除掉许多不好的情况， 如果没有这种限制的话， 原型链末端的“实例” 可能会意外地获取 其他地方的属性（这些属性隐式被所有“实例” 所“共享”）。 所以， class 语法实际上可以帮助避免犯错。 
- 可以通过 extends 很自然地扩展对象（子） 类型， 甚至是内置的对象（子） 类型， 比如 Array 或 RegExp。 没有 class ..extends 语法时， 想实现这一点是非常困难的。

class 基本上只是现有 [[Prototype]] 委托机制的一种语法糖。也就是说， class 并不会像传统面向类的语言一样在声明时静态复制所有行为。 如果你（有意或无意）修改或者替换了父“类” 中的一个方法， 那子“类” 和所有实例都会受到影响， 因为它们在定义时并没有进行复制， 只是使用基于 [[Prototype]] 的实时委托。

class 语法无法定义类成员属性（只能定义方法）， 如果为了跟踪实例之间共享状态必须要 这么做， 那你只能使用丑陋的 .prototype 语法。这种方法最大的问题是，它违背了class语法的本意，在实现中暴露了.prototype。此外， class 语法仍然面临意外屏蔽的问题。

出于性能考虑（this 绑定已经是很大的开销了）， super 并不是动态绑定的， 它会在声明时“静态” 绑定。   

总地来说， ES6 的 class 想伪装成一种很好的语法问题的解决方案， 但是实际上却让问题 更难解决而且让 JavaScript 更加难以理解。  



