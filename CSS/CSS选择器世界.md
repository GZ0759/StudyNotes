> CSS选择器世界  
> 张鑫旭   
> 2019年10月第一版  

# 第 1 章 概述 

CSS 选择器本身很简单，就是一些特定的选择符号。实际上， CSS 选择器非常强大，它不仅涉及视觉表现，而且与用户安全、用户体验有非常密切的联系。

## 1.1 为什么CSS选择器很强 

不少开发人员习惯把 CSS 属性或者 CSS 选择器看成一个个独立的个体，就好像传统编程语言中一个个 API 一样。传统编程语言讲求逻辑清晰，层次分明，主要为功能服务，因此这种不脱泥带水的 API 是非常有必要的。但 CSS 确实为样式服务的，它重表现，轻逻辑，如同人的思想一样，相互碰撞才能产生火花。

## 1.2 CSS选择器世界的一些基本概念 
### 1.2.1 选择器、选择符、伪类和伪元素 

CSS 选择器可以分为 4 类，即选择器、选择符、伪类和伪元素。

1. 选择器。这里的“选择器”指的就是平常使用的CSS声明块前面的标签、类名等。
2. 选择符。目前所知道的CSS选择器世界中的选择符有5个，即表示后代关系的空格` `,表示父子关系的尖括号`>`,表示相邻兄弟关系的加号`+`,表示兄弟关系的弯弯`~`,以及表示列关系的双管道`||`。
3. 伪类。伪类的特征是其前面会有一个冒号`:`,通常与浏览器行为和用户行为相关联，可以看成是CSS世界的JavaScript。伪类和选择符相互配合可以实现非常多的纯CSS交互效果。
4. 伪元素。伪元素的特征是其前面会有两个冒号`::`，常见的有`::before`,`::after`,`::first-letter`和`::first-line`等。

### 1.2.2 CSS选择器的作用域 

以前CSS选择器只有一个全局作用域，也就是在网页任意地方的CSS都共用一个文档上下文。如今css选择器是有局部作用域的概念的。伪类`:scope`的设计初衷就是匹配局部作用域下的元素。实际上此特性曾被浏览器支持过，但只是县花一现，现在已经被舍弃。

### 1.2.3 CSS选择器的命名空间 

命名空间可以让来自多个 XML 词汇表的元素的属性或样式彼此之间没有冲突，它的使用非常常见，例如 XHTML 文档。

在CSS选择器世界中命名空间的作用也是避免冲突。例如，在HTML和SVG中都会用到`<a>`链接，此时就可能发生冲突，我们可以借助命名空间进行规避，具体方法是，使用`@namespace`规则声明命名空间：

```css
@namespace url(http://www.w3.org/1999/xhtm1);
@namespace svg url(http://www.w3.org/2000/svg);
/*XHTML中的<a>元素*/
a {}
/*SVG中<a>元素*/
svg | a {}
/*同时匹配XHTML和svG的<a>元素*/
* | a {}
```

## 1.3 无效CSS选择器特性与实际应用 

很多 CSS 伪类选择器是最近几年才出现的，浏览器并不支持，浏览器会把这些选择器当作无效选择器，这是没有任何问题的。但是当这些无效的 CSS 选择器和浏览器支持的 CSS 选择器写在一起的时候，会导致整个选择器无效，举个例子，有如下 CSS 代码。

# 第 2 章 CSS选择器的优先级 

几乎所有的 CSS 样式冲突、样式覆盖等问题都与 CSS 声明的优先级错位有关。因此，在详细阐述 CSS 选择器的优先级规则之前，先快速了解一下 CSS 全部的优先级规则。

- 0级：通配选择器选择符和逻辑组合伪类。其中，通配选择器写作星号`*`，通配符指`+`、`>`、`~`、空格和`||`，逻辑组合伪类`:not()`、`:is()`和`:where()`等，这些伪类本身并不影响 CSS 优先级，影响优先级的是括号里面的选择器。
- 1级：标签选择器。
- 2级：类选择器、属性选择器和伪类。
- 3级：ID选择器。
- 4级：style属性内联。
- 5级：`!important`。`!important`是顶级优先级，可以重置 JavaScript 设置的样式，唯一推荐使用的场景就是使 JavaScript 设置无效。

## 2.1 CSS优先级规则概览 

CSS 优先级有着明显的不可逾越的等级规则，将其划分为 0 ~ 5 这六个等级，其中前四个等级由 CSS 选择器决定，后两个等级由书写形式和特定语法决定。

## 2.2 深入CSS选择器优先级 
### 2.2.1 CSS选择器优先级的计算规则 

对于CSS选择器优先级的计算，业界流传甚广的是数值计数法。具体如下：每一段CSS语句的选择器都可以对应一个具体的数值，数值越大优先级越高，其中的CSS语句将被优先渲染。其中，出现一个0级选择器，优先级数值+0;出现一个1级选择器，优先级数值+1;出现一个2级选择器，优先级数值+10;出现一个3级选择器，优先级数值+100。

增加 CSS 选择器优先级的小技巧

- 重复选择器自身
- 借助存在的属性选择器

对数值记数法的点评

上面提到的 CSS 选择器优先级数值的记数法是实际上是一个不严谨的方法。

### 2.2.2 256个选择器的越级现象 

同样，256个标签选择器的优先级大于类名选择器的优先级的现象也是存在的。

实际上，在过去，Chrome浏览器、Firefox浏览器下都出现过这种256个选择器的优先级大于上一个选择器级别的现象，后来，大约2015年之后，Chrome浏览器和Firefox浏览器都修改了策略，使得再多的选择器的优先级也无法超过上一级，因此，目前越级现象仅在IE浏览器中可见。

为什么会有这种有趣的现象呢？早些年查看Firefox浏览器的源代码，发现所有的类名都是以8字节字符串存储的，8字节所能容纳的最大值就是255,因此同时出现256个类名的时候，势必会越过其边缘，滋出到ID区域。而现在采用了16字节的字符串存储，能容纳的类型数量足够多了，就不会出现这种现象。

## 2.3 为什么按钮：hover变色了 
# 第 3 章 CSS选择器的命名 

CSS 选择器的命名问题是最常困扰开发者的事情之一。究竟是面向 CSS 属性命名，还是面向 HTML 语义命名？是使用长命名，还是使用短命名？

## 3.1 CSS选择器是否区分大小写 

CSS选择器有些区分大小写，有些不区分大小写，还有些可以设置为不区分。

要搞清楚CSS选择器是否区分大小写的问题，还要从HTML说起。在HTML中，标签和属性都是不区分大小写的，而属性值是区分大小写的。于是，相对应地，在CSS中，标签选择器不区分大小写，属性选择器中的属性也不区分大小写，而类选择器和ID选择器本质上是属性值，因此要区分大小写。

## 3.2 CSS选择器命名的合法性 
## 3.3 CSS选择器的命名是一个哲学问题 
### 3.3.1 长命名还是短命名 
### 3.3.2 单命名还是组合命名 
### 3.3.3 面向属性的命名和面向语义的命名 

表3-2两种选择器命名的优缺点对比

| 优点 | 缺点 |  |
|---|---|---|
| 面向属性的命名 | 重用性高，方便快捷 | 适用场景有限 |
| 面向语义的命名 | 灵活丰富，应用场景广泛 | 代码笨重，效率一般 |

### 3.3.4 我是如何取名的 
## 3.4 CSS选择器设计的最佳实践 
### 3.4.1 不要使用ID选择器 

没有任何理由在实际项目中使用ID选择器。

虽然ID选择器的性能很不错，可以和类选择器分庭抗礼，但是由于它存在下面两个巨大缺陷，这个本就不太重要的优点更加不值一提。

- 优先级太高。ID选择器的优先级实在是太高了，如果我们想重置某些样式，必然还需要ID选择器进行覆盖，再多的类名都没有用，这会使得整个项目选择器的优先级变得非常混乱。如果非要使用元素的ID作为选择器标识，请使用属性选择器，如`[id="csId"]`。
- 和 JavaScript 耦合。实际开发时，元素的ID主要用在JavaScript中，以方便DOM元素快速获取它。如果ID同时和样式关联，它的可维护性会大打折扣。一旦ID变化，必须同时修改CSS和JavaScript,然而实际上开发人员只会修改一处，这就是很多后期bug产生的原因。


### 3.4.2 不要嵌套选择器 
### 3.4.3 不要歧视面向属性的命名 
### 3.4.4 正确使用状态类名 
### 3.4.5 最佳实践汇总 

# 第 4 章 精通CSS选择符 
## 4.1 后代选择符空格（ ） 
### 4.1.1 对CSS后代选择符可能错误的认识 
### 4.1.2 对JavaScript中后代选择符可能错误的认识 
## 4.2 子选择符箭头（>） 

子选择符只会匹配第一代子元素，而后代选择符会匹配所有子元素。

### 4.2.1 子选择符和后代选择符的区别 
### 4.2.2 适合使用子选择符的场景 
## 4.3 相邻兄弟选择符加号（+） 
### 4.3.1 相邻兄弟选择符的相关细节 
### 4.3.2 实现类似：first-child的效果 
### 4.3.3 众多高级选择器技术的核心 
## 4.4 随后兄弟选择符弯弯（~） 

相邻兄弟选择符只会匹配它后面的第一个兄弟元素，而随后兄弟选择符会匹配后面的所有兄弟元素。

### 4.4.1 和相邻兄弟选择符区别 
### 4.4.2 为什么没有前面兄弟选择符 
### 4.4.3 如何实现前面兄弟选择符的效果 
## 4.5 快速了解列选择符双管道（||） 

# 第 5 章 元素选择器 

元素选择器主要包括两类，一类是标签选择器，一类是通配符选择器。

## 5.1 元素选择器的级联语法 

不同类型的 CSS 选择器的级联使用是非常常见的。

元素选择器的级联语法和其他选择器的级联语法有两个明显的不同之处。

- 元素选择器是唯一不能重复自身的选择器
- 级联使用的时候元素选择器必须写在最前面

## 5.2 标签选择器二三事 
### 5.2.1 标签选择器混合其他选择器的优化 
### 5.2.2 标签选择器与自定义元素 
## 5.3 特殊的标签选择器：通配选择器 

通配选择器是一个特殊的标签选择器，它可以指代所有类型的标签元素，包括自定义元素，以及`<script>`、`<style>`、`<title>`等元素，但是不包括伪元素。

它的用法是使用字符星号（`*`,即U+002A）,例如：

由于通配选择器（*）匹配所有元素，因此它是比较消耗性能的一种CSS选择器，同时由于其影响甚广，容易出现一些意料之外的样式问题，因此请谨慎使用。

# 第 6 章 属性选择器 
## 6.1 ID选择器和类选择器 

ID选择器和类选择器都属于属性选择器，它们的身份看起来高贵而特殊，毕竟HTML原生属性那么多，就id和class两个属性有专门的选择器。实际上，正是因为它们足够普通才有此待遇，几乎所有的HTML元素都支持这两个属性。name、type这些属性也很常见，但它们主要出现在控件元素上，如果所有元素都支持name属性，相信它也会有专属于自己的属性选择器的。

ID选择器和类选择器虽然性质一致，都属于属性选择器，但是它们的实际表现却有明显差异。

- 语法不同
- 优先级不同
- 唯一性与可重复性

## 6.2 属性值直接匹配选择器 

属性值直接匹配选择器包括下面 4 种：

- [attr]
- [attr="val"]
- [attr~="val"]
- [attr|="val"]

### 6.2.1 详细了解4种选择器 

1. `[attr]`

`[attr]`表示只要包含指定的属性就匹配，尤其适用于一些HTML布尔属性，这些布尔属性只要有属性值，无论值的内容是什么，都认为这些属性的值是true。

2. `[attr="val"]`

`[attr="val"]`是属性值完全匹配选择器，例如，匹配单复选框：

```css
[type="radio"] {}
[type="checkbox"] {}
```

3. `[attr~="val"]`

`[attr~="val"]`是属性值单词完全匹配选择器，专门用来匹配属性中的单词，其中，`~=`用来连接属性和属性值。

4. `[attr|="val"]`

`[attr|="val"]`是属性值起始片段完全匹配选择器，表示具有 attr 属性的元素，其值要么正好是 val ,要么以 val 外加短横线`-`（U+002D）开头，`|=`用于连接需要匹配的属性和属性内容。

```html
<!--匹配-->
<div attr="val"></div>
<!--匹配-->
<div attr="val-ue"></div>
<!--匹配-->
<div attr="val-ue bar"></div>

<!--不匹配-->
<div attr="value"></div>
<!--不匹配-->
<div attr="val var"></div>
<!--不匹配-->
<div attr="var val-ue"></div>
```

可以看到，这个选择器必须严格遵循开头匹配的规则。

另外，这个选择器设计的初衷是子语言匹配，用在`<a>`元素的 hreflang 属性或者任意元素的 lang 属性中。

例如，同样是中文，它们也会有简体中文和繁体中文的差异，最新的标记如下：

- 简体中文有 zh-cmn-Hans
- 繁体中文有 zh-cmn-Hant
- 英文则有 en-US、en-Latn-US、en-GB

### 6.2.2 AMCSS开发模式简介 
## 6.3 属性值正则匹配选择器 

属性值正则匹配选择器包括下面3种：

- `[attr^="val"]`
- `[attr$="val"]`
- `[attr*="val"]`

这3种属性选择器就完全是字符匹配了，而非单词匹配。其中，尖角符号`^`、美元符号`$`以及星号`*`都是正则表达式中的特殊标识符，分别表示前匹配、后匹配和任意匹配。

这几个选择器的兼容性不错，IE7及以上版本的浏览器均支持。

### 6.3.1 详细了解3种选择器 
### 6.3.2 CSS属性选择器搜索过滤技术 

我们可以借助属性选择器来辅助我们实现搜索过滤效果，如通讯录、城市列表，这样做性能高，代码少。HTML结构如下：

```html
<input type="search" placeholder="输入城市名称或拼音" />
<ul>
    <li data-search="重庆市 chongqing">重庆市</li>
    <li data-search="哈尔滨市 haerbin">哈尔滨市</li>
    <li data-search="长春市 changchun">长春市</li>
</ul>
```

此时，当我们在输入框中输入内容的时候，只要根据输入内容动态创建一段CSS代码就可以实现搜索匹配效果了，无须自己写代码进行匹配验证。

```js
var eleStyle - document.createElement('style') ;
document.head.appendChild(eleStyle);
// 文本框输入
input.addEventlistener("input", function(){
    var value = this.value.trim();
    eleStyle.innerHTML = value ? '[data-search]:not([data-search*="' + value + '"]){ display: none;}' : '' ;
}):
```

## 6.4 忽略属性值大小写的正则匹配运算符 

# 第 7 章 用户行为伪类 

用户行为伪类是指与用户行为相关的一些伪类，例如，经过`:hover`、按下`:active`以及聚焦`:focus`等。

## 7.1 手型经过伪类:hover 
### 7.1.1 体验优化与:hover延时 
### 7.1.2 非子元素的:hover显示 
### 7.1.3 纯:hover显示浮层的体验问题 
## 7.2 激活状态伪类:active 
### 7.2.1 :active伪类概述 
### 7.2.2 按钮的通用:active样式技巧 
### 7.2.3 :active伪类与CSS数据上报 
## 7.3 焦点伪类:focus 
### 7.3.1 :focus伪类匹配机制 
### 7.3.2 :focus伪类与outline 
### 7.3.3 CSS :focus伪类与键盘无障碍访问 
## 7.4 整体焦点伪类:focus-within 
### 7.4.1 :focus-within和:focus伪类的区别 
### 7.4.2 :focus-within实现无障碍访问的下拉列表 
## 7.5 键盘焦点伪类:focus-visible 

# 第 8 章 URL定位伪类 
8.1 链接历史伪类:link和:visited 
8.1.1 深入理解:link 
8.1.2 怪癖最多的CSS伪类:visited 
8.2 超链接伪类:any-link 
8.3 目标伪类:target 
8.3.1 :target与锚点 
8.3.2 :target交互布局技术简介 
8.4 目标容器伪类:target-within 
第9章 输入伪类 
9.1 输入控件状态 
9.1.1 可用状态与禁用状态伪类:enabled和:disabled 
9.1.2 读写特性伪类:read-only和:read-write 
9.1.3 占位符显示伪类:placeholder-shown 
9.1.4 默认选项伪类:default 
9.2 输入值状态 
9.2.1 选中选项伪类:checked 
9.2.2 不确定值伪类:indeterminate 
9.3 输入值验证 
9.3.1 有效性验证伪类:valid和:invalid 
9.3.2 范围验证伪类:in-range和:out-of-range 
9.3.3 可选性伪类:required和:optional 
9.3.4 用户交互伪类:user-invalid和空值伪类:blank 
# 第 10 章 树结构伪类 
10.1 :root伪类 
10.1.1 :root伪类和元素 
10.1.2 :root伪类的应用场景 
10.2 :empty伪类 
10.2.1 对:empty伪类可能的误解 
10.2.2 超实用超高频使用的:empty伪类 
10.3 子索引伪类 
10.3.1 :first-child伪类和:last-child伪类 
10.3.2 :only-child伪类 
10.3.3 :nth-child()伪类和:nth-last-child()伪类 
10.4 匹配类型的子索引伪类 
10.4.1 :first-of-type伪类和:last-of-type伪类 
10.4.2 :only-of-type伪类 
10.4.3 :nth-of-type()伪类和:nth-last-of-type()伪类 
# 第 11 章 逻辑组合伪类 
11.1 否定伪类:not() 
11.2 了解任意匹配伪类:is() 
11.2.1 :is()伪类与:matches()伪类及:any()伪类之间的关系 
11.2.2 :is()伪类的语法与作用 
11.3 了解任意匹配伪类:where() 
11.4 了解关联伪类:has() 
# 第 12 章 其他伪类选择器 
12.1 与作用域相关的伪类 
12.1.1 参考元素伪类:scope 
12.1.2 Shadow树根元素伪类:host 
12.1.3 Shadow树根元素匹配伪类:host() 
12.1.4 Shadow树根元素上下文匹配伪类:host-context() 
12.2 与全屏相关的伪类:fullscreen 
12.3 了解语言相关伪类 
12.3.1 方向伪类:dir() 
12.3.2 语言伪类:lang() 
12.4 了解资源状态伪类 