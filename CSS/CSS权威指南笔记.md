> CSS权威指南第三版
> CSS:The Definitive Guide
> 2017年10第一次出版

# 第1章 CSS和文档

1.1 web的衰落
1.2 CSS作救星

## 1.3  元素

元素（element）是文档结构的基础，文档结构中的每个元素都对文档的表现起一定作用，每个元素生成一个框（box，也称为盒），其中包含元素的内容。

在CSS中，元素通常有两种形式，替换和非替换。
替换元素是指用来替换元素内容的部分而非由文档内容直接显示。
大多数HTML和XHTML元素都是非替换元素，其内容由用户代理（通常是一个浏览器）在元素本身生成的框架中显示。
	
CSS2.1还使用另外两种基本元素类型：块级元素（block-level）和行内元素（inline-level）。
块级元素生成一个元素框，（默认地）它会填充其父元素的内容区，旁边不能由其他元素。列表项是块级元素的一个特例。
行内元素在一个文本行内生成元素框，而不会打断这行文本。
	

## 1.4  结合CSS和xHTML

1.4.1 link标记
link标记是一个很少用但完全合法的标记，其基本目的是允许HTML创作人员将包含link标记的文档与其它文档相关联，这些样式表称为外部样式表。另外，link必须放在head元素中，但不能放在其他元素内部（如title）。
	
link属性：rel、type、href、media.
rel代表“关系”，关系为一般是stylesheet，当属性的值为alternate stylesheet时定义为候选样式表只有在用户选择这个样式表时才会用于文档表现。type总是设置为text/css，这个值描述了使用link标记加载的数据的类型。hrel属性的值是样式表的URL，可以是绝对URL，也可以是相对URL。media属性表明样式表要应用于那些表现媒体。
	
1.4.2 style元素
可以用style元素包含样式表，它在文档中单独出现。开始和结束style标记之间的样式称为文档样式表，或嵌套样式表，还可以使用@import指令包含多个外部样式表链接。
	
1.4.3 CSS注释
CSS支持单行注释、跨行注释，使用/*和*/包围即可。
	
1.4.4 内联样式
为单个元素指定一些样式，可以直接使用HTML的style属性来设置一个内联样式，使用双引号进行包围
	
1.4小结

# 第2章 选择器

## 2.1 基本规则

选择器和声明块，声明块由一个或多个声明组成，每个声明则是一个属性-值对（属性后面跟一个冒号，然后一个值，然后分号，冒号和分号后面可以有0个或者多个空格，值要么是一个关键字，要么是该属性可取关键字的一个列表，CSS关键字往往由空格分隔，在CSS的font属性中却可以使用斜线来分割两个特定关键字，大小和行高），每个样式表由一系列规则组成。文档的元素就是最基本的选择器
	

## 2.2 分组

将选择器放在规则的左边，并用逗号来分割，则将右边的样式应用到这些选择器所应用的元素。星号*这个选择器可以与任何元素匹配，称为统配选择器。声明分组，必须在每个声明最后使用分号。
	

## 2.3 类选择器和ID选择器

在类名前又一个号点好，即可结合成一个简单选择器。如果只想选择所有类名相同的元素，可以在类选择器中忽略通配选择器。一个class值中可能包含一个词列表，各个词之间用空格分隔，则选择器可以通过空格将这两个类选择器链接起来，顺序不限，但如果其中包含类名列表没有的类名，则匹配失败，即类选择器的类至少是类名列表的子集。
	
ID选择器前有有一个#号，也称为棋盘号而不是点号。在一个HTML文档中，ID选择器会使用一次，而且仅一次。不同于类选择器，ID选择器不能结合使用，因为ID属性不允许以空格分隔的词列表。类选择器和ID选择器是区分大小写的。
	

## 2.4 属性选择器

四种类型的属性选择器，简单属性选择、根据具体属性值选择、根据部分属性值选择、特定属性选择类型。
	
简单属性选择，只希望有class属性的所有元素都能匹配。可以多个属性一起匹配。
	
根据具体属性值选择，为了进一步缩小选择范围，值选择有特定属性值的元素。这个格式要求必须与属性值完全匹配，是因为属性值都是用双引号包围。
	
根据部分属性值选择，接受一个或者多个词作为其属性值的属性都能使用，但必须用"~="代替"="，字串撇配属性选择器还有"^="（开头）、"$="（结尾）、"*="（包含）
	
特定属性选择类型。类似部分属性值选择，这个是选择以该属性值相等或者以该属性值开头的所有元素，符号是|=
	

## 2.5 使用文档结构

通过结构模式，可以定义后代选择器和上下文选择器。
	
在一个后代选择器中，规则左边的选择器一端包含两个或多个用空格分隔的选择器，两个元素之间的层次间隔可以是无限的，不管嵌套层次多深。
	
选择子元素。可以使用子结合符，即用大于号">"来选择一个元素的子元素。
	
选择相邻兄弟元素，相邻兄弟符"+"可以选择相邻的元素，要求是这两个元素有共同的父元素。两个元素之间的其它元素不会影响到相邻兄弟结合符起作用。
	

## 2.6 伪类和伪元素

所有伪类和伪元素关键字前面都有一个冒号。

链接伪类有link，提示作为超链接并指向一个未访问地址的所有锚、visited提示作为已访问地址超链接的所有锚，动态伪类有三个，根据用户行为改变文档外观，包括focus、hover、active
	
选择第一个子元素"first-child"，是将任意元素的第一个子元素是该元素类型的元素进行匹配。
	
根据语言选择的伪类（lang）。除了互斥的伪类，其它伪类元素可以结合使用，哪种顺序指定不重要。
	
以上是伪类选择器，接下来是伪元素选择器。
	
设置首字母样式（first-letter）、设置第一行的样式（first、line），这两个伪元素应用有一定的限制。另外，所有伪元素都必须放在出现该伪元素的选择器的最后面，伪元素before和after直接设置样式，可以插入生成内容，所生成的内容是一个单独的主体。
	

## 2.7 小结

选择器有元素选择器、类选择器、ID选择器、文档结构相关的选择器、伪元素和伪类的选择器。后代选择器，每个选择器之间用空格分开；子代选择器，每个选择器之间用“>”表示；交集选择器，每个选择器之间没有任何符号。

# 第3章 结构和层叠

## 3.1 特殊性

选择器有特殊性，对于每个规则，用户代理会计算选择器的特殊性，并将这个特殊性附加到规则中的各个声明，如果一个元素有两个或多个冲突的属性声明，那么有最高特殊性的声明就会胜出。内联样式特殊性最高，接下来的特殊性由高到低分别是，ID选择器、类选择器、元素/伪元素选择器、结合符通配符选择器对待特殊性没有任何贡献。同时特殊性是量叠加和比较的，值是从左到有排序的。

任何情况下，用户代理都会确定哪些规则与一个元素匹配，计算出所有相关的声明以及特殊性，确定哪些规则胜出，然后将胜出的规则应用到元素，从而得到应用样式后的结果。这个行为是层叠的一个重要部分。
声明的重要性，如果某个规则中的声明的重要性超过其它的，那么我们可以用用药声明!important来标志，这个是在该声明的结束分号之前插入的。重要声明如果和非重要声明冲突，胜利的总是重要声明，至于特殊性，重要声明的特殊性会在重要声明内部解决，而不会与非重要声明想混。

## 3.2 继承

基于继承机制，样式不仅应用到指定的元素，还会用到它的后代元素。但是有些属性不能继承，例如border边框、外边距、内边距、背景等框模型属性，继承的值没有特殊性，甚至比通配符选择器的都要低。

## 3.3 层叠

CSS解决冲突的方法就是让样式层叠在一起，这是通过结合继承和特殊性做到的，又叫样式优先级，浏览器根据样式来源进行叠加，最终确定结果的过程。层叠规则很简单。
首先按显式权重对应用到该元素的所有声明排序，标志!impotant的规则的权重要高于没有该标志的规则；按来源对应用到给定元素的所有声明排序，共创作人员、读者和用户代理三种。正常情况下，创作人员、读者和用户代理的级别会相应降低，但有!important标志的读者样式胜于所有其它样式。
第二点，按特殊性对应到给定元素的所有声明排序，有较高特殊性的元素权重要大于有较低特殊性的元素。
第三点，按出现顺序对应用到给定元素的所有声明排序。一个声明在样式表或文档中越后出现，它的权重就越大。如果是导入的样式表，一般认为在前，其它声明在后。

## 3.4 小结

根据视频资料总结，！Important声明最高，然后是使用方法的优先级，然后是样式表总特殊性权重的优先级。

# 第4章 值和单位

## 4.1 数字

CSS中有两类数字，整数（完整的数）和实数（小数），这些作为其他值类型的基础，也可以用作属性的值。整数和实数都可以是正数或负数，不过属性可能限制所允许的数字范围。

## 4.2 百分数

百分数值是一个计算得出的实数，其后跟有一个百分号（%）。百分数值几乎是总是相对于另外一个值，这个值可以是任意的，可能是同一元素另一个属性的值，也可以是从父元素继承的一个值，或者是祖先元素的一个值。

## 4.3 颜色

HTML和CSS颜色规范中定义了147种颜色名，其中有17种是标准颜色。
计算机通过组合不同的红色、绿色和蓝色分量来创造颜色，这种组合通常称为RGB颜色。函数式RGB颜色，有三个百分数值或者三个整数；十六进制RGB颜色，数值介乎00到FF之间，如果三组数都是成对的，可以采用简写的方式

## 4.4 长度单位

很多CSS属性都依赖于长度度量来适当地显示各种页面元素。这些长度单位可以划归为两类，绝对长度单位和相对长度单位。
绝对长度单位有五种：英寸（in）、厘米（cm）、毫米（mm）、点（pt）、派卡（pc），相对长度单位有em、ex、px三种，，一个em定义为一种给定字体的font-size值，如果一个元素的font-size为14像素，那么对于该元素1em就等于14像素，这个单位比较灵活，可以随字体大小缩放。ex是指所用字体中小写x的高度。像素长度单位是px，读u如元素的边框或定位，就比较适合用像素。

## 4.5 URL

URL有绝对URL和相对URL，有时一个值需要用某个词来描述，这个词就称为关键字，常用的就是none关键字。inherit是一个所有属性公有的关键字，使一个属性的值与其父元素的值相同，不必指定继承。

## 4.6 css2单位

还有几个与声音样式表相关的单位。分别是角度值、时间值和频率值。

4.7小结

# 第5章 字体

## 5.1 字体系列

属性font-family在文档中可以表示字体系列，如果希望文档接收多种字体，可以先确定字体的优先顺序，然后用逗号项链，如果列出的字体都不可用，那么就会简单地选择一种可用的serif字体。当一个字体名有一个或多个空格，或者字体名包含#或$之类的符号，才需要在font-family声明中加引号。

## 5.2 字体加粗

利用font-weight属性，CSS允许对字体加粗有更多控制，指定的数字从100到900，其中400代表normal，700代表bold，另外还有bolder、lighter和inherit等值。

## 5.3 字体大小

font-size属性有两个相对大小关键字：larger和smaller，会导致计算值上移或下移。还有七个绝对大小值：xx-small、x-small、small、medium、large、x-large、xx-large。在某种程度上讲，百分数值与相对大小关键字很相似，百分数值总是根据从父元素继承的大小来计算。不过，百分数还允许对计算的字体大小有更细的控制。

## 5.4 风格和变形

font-style属性用于在normal文本、italic文本和oblique文本，表示标准、斜体和倾斜三种字体样式。
font-variant属性有两个非继承属性，默认值normal和small-caps，前者描述正常文本，后者要求使用小型大写字母文本。

5.5拉伸和调整字体

## 5.6 font属性

font声明可以有其它字体属性的任何值，可以按顺序设置如下属性：font-style、font-variant、font-weight、font-size/line-height、font-family

5.7字体匹配
5.8小结

# 第6章 文本属性

## 6.1 缩进和水平对齐

通过使用 text-indent 属性，所有元素的第一行都可以缩紧一个给定的长度，甚至该长度可以是负值。一般地，可以为所有块级元素应用text-indent，但无法将这个属性应用到行内元素（如果要把一个行内元素的第一行进行缩进，可以利用左内边距和左外边距），图像之类的替换元素上也无法应用该属性。这个属性可以使用所有长度单位，并且可以继承。

text-align 是一个影响元素中的文本行相互之间的对齐方式的属性，它只应用于块级元素（如段落），值 left、right 和center 会导致元素中的文本左对齐、右对齐和居中对齐。最后一个水平对齐属性时 justify ，在两端对齐文本中，文本行得左右两端都放在父元素的内边界上。

## 6.2 垂直对齐

line-height 属性时值文本行基线之间的距离，而不是字体的大小，它确定了将各个元素框的高度增加或减少多少。在最基本的情况下，指定 line-height 可以用来增加（或减少）文本行之间的垂直间隔。它控制着行间距，line-height 值和字体大小之差就是行间距。在应用到块级元素时，line-height 定义了元素中文本基线之间的最小距离，最小距离不是一个绝对数值，文本基线拉开的距离可能比 line-height 值更大。行高是可以继承的。
	
vertical-align 属性只应用于行内元素和替换元素。该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。下标 sub 和上标 super，可以使元素的基线相对于父元素的基线下降或升高。同时还允许指定长度值和百分比值，正值使元素升高，负值使元素下降。在表单元格中，这个属性会设置单元格框中的单元格内容的对齐方式。

## 6.3 字间隔和字母间隔

字间间隔 word-spacing 属性接收一个正长度值或负长度值，这个长度会增加到字之间的标准间隔。
	
字母间隔 letter-spacing 属性的可取值包括所有长度，默认关键字normal，效果等于`letter-spacing: 0`，输入的长度值会使字母间的间隔增加或减少指定的量。

## 6.4 文本转换

text-transform 这个属性会改变元素中的字母大小写。默认值 none 对文本不做任何改动，将使用源文档中原有的大小写。uppercase 和 lowercase 将文本转换为全大写或全小写字符，而 capitalize 只对每个单词的首字母大写。

## 6.5 文本装饰

text-decoration 这个属性允许对文本设置某种效果，下划线 underline，上划线 overline 和贯穿线 line-through。该元素的值不能继承，但是如果后代元素没有自己的装饰，祖先元素上设置的装饰会“延伸”到后代元素中。

## 6.6 文本阴影

text-shadow 属性向文本添加一个或多个阴影。该属性是逗号分隔的阴影列表，每个阴影有一个可选的颜色值和三个（第三个可省略）长度值进行规定。省略的长度是 0。

## 6.7 其它

属性 white-space 会影响用户代理对源文档中的空格、换行和 tab 字符的处理。

属性 direction 影响块级元素中文本的书写方向、表中列布局的方向、内容水平填充其元素框的方向，以及两端对齐元素中最后一行的位置。

6.8 小结

# 第7章 基本视觉格式化

## 7.1 基本框

CSS假设每个元素都会生成一个或多个矩形框，这称为元素框，各元素框中心有一个内容区，内容区周围有可选的内边距、边框和外边距。外边距通常是透明的，从中可以看到父元素的背景，内边距不能是负值但是外边距可以。

包含块。每个元素都相对于其包含块来摆放，包含块就是一个元素的“布局上下文”。对于正常的西方语言文本流中的一个元素，包含块由最近的块级祖先框、表单元格或行内块祖先框的内容边界构成。

正常流。这是指西方语言文本从左向右、从上到下显示，这也是我们熟悉的传统HTML文档的文本流局。要让一个元素不再正常流中，唯一的办法就是使之成为浮动或定位元素。

非替换元素。如果元素的内容包含在文档中，则称之为非替换元素。

替换元素。这是指用作为其他内容占位符的一个元素。例如img元素只是指向一个图像文件的替换元素。

块级元素。这些元素在正常流中时，会在其框之前和之后生成“换行”。所以处于正常流中的块级元素会垂直摆放，通过声明display:block，可以让元素生成块级框。

行内元素。这些元素不会再之前或之后生成“行分隔符”，它们是块级元素的后代。通过声明display:inline，可以让元素生成一个行内框。

根元素。位于文档树顶端的元素。在HTML文档中，这就是元素html。

## 7.2 块级元素

一般地，一个元素的width被定义为从左内边界到由内边界的距离，height则是从上内边界到下内边界的距离。

水平格式化。width影响的是内容区的宽度，而不是整个可见的元素框。如果指定了内边距、边框或外边距，这些都会增加到宽度值。对此有一个很简单的规则，正常流中块级元素框的水平部分总和就等于父元素的width。

水平属性。水平格式化有“7大属性”（margin-left、border-left、padding-left、width、padding-right、border-right、margin-right），这些属性的值加起来必须是包含块的宽度，这往往是块级元素的父元素的width。其中只有3个属性可以设置为auto：width、左右外边距。如果这三个属性中有一个值为auto，那么设置auto的属性会根据所需的长度，从而使元素框的宽度等于父元素的width。如果都不设置为auto，则会强制把margin-right设置为auto。如果左右两个外边距都设置为auto，那么它们会设置为相等的长度，因此将元素在其父元素中居中。这是一种将元素居中的正确方法，这不同于text-align（text-align只应用于块级元素的内联内容，所以将元素的text-align设置为center并不能将这个元素居中）。如果某个外边距以及width设置为auto，那么这个设置为auto的外边距会减为0。同样，如果三个属性都设置为auto，那么两个外边距都会设置为0，而width会尽可能宽。由于水平外边距不会合并，父元素的内边距、边框和外边距可能影响其子元素，这种效果是间接的。

负外边距。只要七个属性都是大于或等于0的，元素就不会大于其父元素的内容区，但如果外边距出现负值就不一样，虽然属性加起来还是等于所需的总宽度，但是可能出现子元素比父元素还宽的情况。

非替换元素的所有规则同样适用于替换块元素，只有一个例外，如果width为auto，那么替换元素的宽度则是内容的固有宽度。可以为width指定一个特定值来覆盖这个规则。但是注意，元素的高度会随着width的不同成比例的变化，除非height自己也显示设置为一个特定值。反过来也是如此。

垂直格式化。一个元素的默认高度由其内容决定，高度也会受内容宽度的影响，段落越窄，相应地高度就会越高，以便容纳其中所有的内联内容。如果元素内容的高度大于元素框的高度，用户代理的具体行为将取决于overflow属性的值。如果设置的高度大于显示内容所需的高度，多余的高度就会产生一个好像有额外内边距的视觉效果。同样，height定义了内容区的高度，而不是可见元素框的高度，元素框上下的内边距、边框和外边距都会增加到height值。

垂直属性。与水平格式化的情况一样，垂直格式化也有七个相关的属性。但是，如果正常流中一个块元素的上或下外边距设置为 auto ，它会自动计算为0，所以当两个上下外边距都为 auto 时，实际上会重置为0，使元素框没有外边距。因此，将元素垂直居中的唯一办法就是把上下外边距都设置为25%。
如果没有显式声明包含块的height，其子元素的百分数高度会重置为 auto ，那么设置height:50%的段落就与div本身的高度完全相同。但是对于定位元素来说，上下外边距设置为 auto 时，其处理有所不同。

```html
<div style="position: relative; width: 10em; height: 10em; border: 1px solid;">
  <div style="position: absolute; left: 0; width: 100%; background: #CCC;
    top: 0; height: 5em; bottom: 0; margin: auto 0;">
      element D
  </div>
</div>
```

合并垂直外边距。垂直格式化的另一个重要方面是垂直相邻外边距的合并，这种合并行为只应用于外边距，如果元素有内边距和边框，它们绝对不会合并。

负外边距。如果垂直外边距都设置为负值，浏览器会取两个外边距绝对值的最大值。如果一个正外边距与一个负外边距合并，会从正外边距减去这个负外边距的绝对值。上下外边距为负时有一种“拉近”效果。

## 7.3 行内元素

- 匿名文本是指所有未包含在行内元素中的字符串。
- em框在字体中定义，也称为字符框。实际的字形可能比其em框更高或更矮。
- 内容区可以是元素中各字符的em框串在一起构成的框，在替换元素中内容区是元素的固有高度再加上可能有的外边距、边框和内边距。
- 行间距是font-size值和line-height值之差，这个差实际上要分为两半，分别应用到内容区的顶部和底部，行间距值应用于非替换元素。
- 行内框通过向内容区增加行间距来描述。替换元素的行内框高度就是内容区的高度，非替换元素的行内框高度等于line-height的值。行内框在行中根据其vertical-align属性值垂直对齐。
- 行框是包含该行中出现的行内框的最高点和最低点的最小框。
- 行内格式化。行的高度（或行框的高度）由其组成元素和其他内容（如文本）的高度确定。如果为块级元素设置line-height的值，这个值只是应用到块级元素的内联内容时才会有视觉影响。根据CSS规范，在块级元素上生命line-height会为该块级元素的内容设置一个最小行框高度。

行内非替换元素。对于行内非替换元素或匿名文本某一部分，font-size值确定了内容区的高度。行框定义为行中最高行内框的顶端到最低行内框之间的距离，而且各行框的顶端挨着上一行行框的底端。垂直对齐。如果某个行内元素中的font-size比较大或者比较小，垂直对齐的方式会修改整个行框的高度。管理line-height。改变一个行内元素的line-height可能导致文本行互相重叠。有两种方法可以避免内容重叠，一种是对font-size有改变的元素结合使用em单位，另一种是增加段落的line-height，影响整个元素中的每一行，而不只是出现加边框超链接或者字体增大的那一行。缩放行高。通过设置`body { line-height: 1.5; }`来使一个文档中所有元素的line-height都是其font-size的1.5倍。增加框属性。行内元素的内边距、外边距和边框都不会影响到行框的高度，行内元素的边框边界由font-size控制。可以为行内元素指定内边距，这会把边框从文本本身拉开，虽然没有改变内容区的具体形状，不过它会影响到这个元素行内框的高度。至于外边距，实际上外边距不会应用到行内非替换元素的顶端和底端，它们不影响行框的高度，但可能影响一个元素内容的布局。如果左右外边距为负，可能会把文本拉进行内元素，甚至导致重叠。

行内替换元素。一般认为行内替换元素有固定的高度和宽度，在固有高度的替换元素可能导致行框比正常要高，这不会改变行中任何元素的line-height值，包括替换元素本身。同时，行内替换元素也有一个line-height值，vertical-align的百分数值要相对于元素的line-height来计算。增加框属性，内边距和边框像平时一样应用到替换元素，内边距在具体内容外插入空间，边框围绕着内边距，它们会影响行框的高度。外边距也包含在行框中。替换元素和基线。行内替换元素位于基线上，如果向替换元素增加下内边距、外边距或边框，内容区会上移。但是替换元素并没有自己的基线，所以相对来讲最好的办法就是将其行内框的底端与基线对齐。

## 7.4 改变元素显示

display属性设置一个值可以用来影响用户代理显示的方式。

行内块元素是块级元素和行内元素的混合，在外部作为行内框与其他元素和内容相关，在内部会像块级元素一样设置内容的格式，行内块元素也有属性width和height。

run-in元素是一个有意思的块/行内元素混合，可以使某些块级元素成为下一个元素的行内部分。通俗一点，就是说如果一个元素生成run-in框，而且该框后面是一个块级框，那么run-in元素将成为块级框开始处的一个行内框，但是它们仍从文档中的父元素继承属性。注意，只有当run-in框后面是一个块级框时run-in才起作用，如果不是这样，run-in本身将成为块级框。

7.5 小结

# 第8章 内边距、边框和外边距

## 8.1基本元素框

所有文档元素都声称一个矩形框，这称为元素框，它描述了一个元素在文档布局中所占的空间大小。因此，每个框影响着其他元素框的位置和大小。一个元素的width被定义为从左内边界到有内边界的距离，height被定义为上内边界到下内边界的距离，对于这两个属性有一点很重要，它们不能应用到行内非替换元素。伪元素指定的内边距和外边距会影响元素的背景何时结束，右内边距的元素的背景范围会增大，而有外边距的元素的背景则不受影响。

## 8.2外边距

大多数正常流元素间出现的间隔都是因为存在元素外边距。设置外边距会在元素外创建额外的“空白”。“空白”通常指不能放其他元素的区域，而且在这个区域中可以看到父元素的背景。

设置外边距的最简单的办法就是使用属性margin。它可以接受任何长度度量，可以是像素、英寸、毫米或em，默认值是0，如果没有声明就不会出现外边距。也可以对元素的外边距设置百分数值，该百分数是相对于父元素的width计算的，所以如果父元素的width以某种方式发生改变，百分数也会改变。

值复制模式规则如下，有些不不能简便的就使用单边外边距属性。

> • If the value for lefe is missing, use the value provided for right. 
>
> • If the value for bottom is missing, use the value provided for top. 
>
> • If the value for right is missing, use the value provided for top.  

外边距和行内元素。外边距还可以应用到行内元素，但不影响行内非替换元素的行高，不过会影响替换元素的行高。

## 8.3边框

元素的边框就是围绕元素内容和内边距的一条或多条线。因此，元素的背景会在外边框边界处停止，因为背景不会延伸到外边距以内，而边框就在外边距内部。每个边框有三个方面：其宽度或粗细、其样式或外观、以及其颜色。CSS为属性border-style定义了10个不同的非inherit样式，包括默认值none，样式值hidden等价于none，不过应用于表时除外，对于表，hidden用于解决边框冲突。

为边框指定宽度有四种方法，可以指定一个长度值，如4px或0.1em，或者使用三个关键字之一，这三个关键字分别是thin、medium（默认值）和thick，这三个关键字不一定对应某个特定的宽度，它们只是相对定义。如果将border-style设置为none，不仅边框的样式没有了，其宽度也会变成0，边框消失了。但是可以通过引入边框颜色值transparent来创建不可见的边框。

border属性可能的值。

| 值             | 描述                                              |
| -------------- | ------------------------------------------------- |
| *border-width* | 规定边框的宽度。thin \| medium \| thick \| 长度值 |
| *border-style* | 规定边框的样式。见下表                            |
| *border-color* | 规定边框的颜色。颜色 \| transparent               |
| inherit        | 规定应该从父元素继承 border 属性的设置。          |

border-style属性可能的值。

| 值      | 描述                                                         |
| ------- | ------------------------------------------------------------ |
| none    | 定义无边框。                                                 |
| hidden  | 与 "none" 相同。不过应用于表时除外，对于表，hidden 用于解决边框冲突。 |
| dotted  | 定义点状边框。在大多数浏览器中呈现为实线。                   |
| dashed  | 定义虚线。在大多数浏览器中呈现为实线。                       |
| solid   | 定义实线。                                                   |
| double  | 定义双线。双线的宽度等于 border-width 的值。                 |
| groove  | 定义 3D 凹槽边框。其效果取决于 border-color 的值。           |
| ridge   | 定义 3D 垄状边框。其效果取决于 border-color 的值。           |
| inset   | 定义 3D inset 边框。其效果取决于 border-color 的值。         |
| outset  | 定义 3D outset 边框。其效果取决于 border-color 的值。        |
| inherit | 规定应该从父元素继承边框样式。                               |

边框和行内元素。边框应用于上下边时，会进行覆盖内容，但是元素的行高都不会改变，而左右边框不仅该边框可见，而且文本会在其旁边显示，即不会覆盖。

## 8.4内边距

元素框的内边距在边框和内容区之间，控制这个区最简单的属性为padding。默认地，元素没有内边距，段落之间的间隔传统上只由外边距保证。如果没有内边距，元素的边框与元素本身的内容相当接近，因此在元素上放边框时，同时增加内边距通常是一个好主意。内边距的值不能为负数，外边距的值才可以是负数。

8.5小结

## 第9章 颜色和背景

颜色
背景色
背景
小结

# 第10章 浮动和定位

定位的基本思想很简单，它允许你定义元素框相对于其正常位置应该出现在哪里，或者相对于父元素，另一个元素甚至到浏览器窗口本身的位置。浮动不完全是定位，不过它也不是正常流布局。

## 10.1 浮动

CSS允许浮动任何元素，从图像到段落再到列表，所有元素都可以浮动。浮动元素有几点不一样，首先，会以某种方式将浮动元素从文档的正常流中删除。而一个元素浮动时，其他内容会“环绕”该元素，同时浮动元素周围的外边距不会合并。如果一个非替换元素浮动，必须为该元素声明一个width，否则，元素的宽度趋于0。除了left和right外，float属性还有一个值none，用于防止元素浮动。

浮动元素的包含块是其最近的块级祖先元素。此外，浮动元素会生成一个块级框，而不论这个元素本身是什么。有一系列特定规则控制着浮动元素的摆放。

1. 浮动元素的左（或右）外边界不能超出其包含块的左（或右）内边界。
2. 浮动元素的左（或右）外边界必须是源文档中之前出现的左浮动（或右浮动）元素的右（左）外边界，除非后出现浮动元素的顶端在先出现浮动元素的顶端下面。防止浮动元素彼此覆盖。
3. 左浮动元素的右外边界不会再其右边有浮动元素的左外边界的右边。一个右浮动元素的左外边界不会再其左边任何左浮动元素的右边界的左边。防止浮动元素相互重叠。
4. 一个浮动元素的顶端不能比其父元素的内顶端更高。如果一个浮动元素在两个合并外边距之间，放置这个浮动元素时就好像在两个元素质检有一个块级父元素。
5. 浮动元素的顶端不能比之前所有浮动元素或块级元素的顶端更高。
6. 如果源文档中一个浮动元素之前出现另一个元素，浮动元素的顶端不能比包含该元素所生成框的任何行框的顶端更高。
7. 左（或右）浮动元素的左边（或右边）有另一个浮动元素时，前者的右外边界不能在其包含块的右（左）边界的右边（左边）。保证可以“换行”。
8. 浮动元素必须尽可能高的放置。
9. 左浮动元素必须向左尽可能远，右浮动元素则必须向右尽可能远。

实用行为。浮动元素会延伸，从而包含其所有后代浮动元素，所以，通过将父元素设置为浮动元素，就可以把浮动元素包含在其父元素内。负外边距可能导致浮动元素移到其父元素的外面。

浮动元素、内容和重叠。如果行内框与一个浮动元素重叠时，其边框、背景和内容都在该浮动元素“之上”显示。如果是块框，则其边框和背景在其浮动元素的下面显示，而内容在浮动元素的上面显示。

清除浮动。希望将每小节的第一个元素设置为禁止元素很出现在它旁边，如果第一个元素可能放在一个浮动元素旁边，则会向下推，直到出现在浮动元素的下面，而且所有后续内容都在其后面出现。在CSS1和CSS2，clear工作是，它会增加元素的上外边距，使之最后落在浮动元素的下面，这实际上会忽略为清除元素顶端设置的外边距宽度。但在CSS2.1中，引入了一个清除区域，清除区域是在元素上外边距之上增加的额外间隔，不允许任何浮动元素进入这个范围。

浮动副作用的解决办法（塌陷问题），手动给父元素添加高度，或通过clear清除内部和外部浮动，或给父元素添加overflow属性并结合`zoom: 1`使用，或给父元素添加浮动。

## 10.2 定位

定位的原理很简单。利用定位，可以准确地定义元素框相对于其正常位置应该出现在哪里，或者相对于父元素，另一个元素甚至浏览器窗口本身得位置。通过使用position属性，可以选择四种不同类型的定位，这会影响元素框生成的方式。

| 值       | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| absolute | 生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。元素框从文档流完全删除，并相对于其包含块定位，元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框。 |
| fixed    | 生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。元素框的表现类似于将position设置为absolute，不过其包含块是视窗本身。 |
| relative | 生成相对定位的元素，相对于其正常位置进行定位。因此，"left:20" 会向元素的 LEFT 位置添加 20 像素。元素仍保持其未定位前的形状，它原本所占的空间仍保留。 |
| static   | 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 |
| inherit  | 规定应该从父元素继承 position 属性的值。                     |

包含块。对于浮动元素，其包含块定义为最近的块级祖先元素。对于定位，情况则没有那么简单。

1. 对于“根元素”，其包含块即初始包含块，由用户代理建立，在大多数浏览器中初始包含块就是视窗。

2. 对于“非根元素”，若元素的position是static或者relative，那么元素的包含块是离其最近的块级框、表单元格或者行内块祖先框的内容边界构成。

3. 对于“非根元素”，若position的值是absolute，其包含块是离其最近的position值不是static的祖先元素（可以是任何类型）。

   若这个祖先元素是块级元素，包含块则设置为该元素的内边距边界

   若这个祖先元素是行内元素，包含块则设置为该元素的内容边界

   若没有position非static的祖先，则其包含块为初始包含块。

偏移属性。这些属性描述了距离包含块最近的偏移。其中正值导致箱内偏移，使边界朝着包含块的中心移动，而负值会导致向外偏移。除了长度值和百分数值，偏移属性还可以设置为auto，这是默认值。

限制宽度和高度。可以使用一下CSS2属性对元素得宽度加一些限制。这些属性用于除了非替换行内元素和表元素之外的所有元素。

| 属性       | 描述                 |
| ---------- | -------------------- |
| max-height | 设置元素的最大高度。 |
| max-width  | 设置元素的最大宽度。 |
| min-height | 设置元素的最小高度。 |
| min-width  | 设置元素的最小宽度。 |

内容溢出和裁剪。使用overflow属性来控制一个固定大小的元素，但内容在元素中放不下的情况。默认值visible声明，元素的内容在元素框之外也可见。如果overflow设置为scroll，元素的内容会在元素框的边界处裁剪，通过滚动条或者其它方法访问内容而不会改变元素本身的形状。如果overflow被设置为hidden，元素的内容会在元素框的边界处裁剪，不过不会提供滚动接口使用户访问超出裁剪区域的内容。如果一个绝对定位元素的内容溢出其内容框，而且overflow设置为要求裁剪该内容，通过使用属性clip可以改变裁剪区域的形状。默认值auto表示元素的内容不应裁剪，还可以相对于元素内容区定义一个裁剪形状，这不会改变内容区的形状，只是改变将显示内容的区域形状。

| 值      | 描述                                                         |
| ------- | ------------------------------------------------------------ |
| *shape* | 设置元素的形状。唯一合法的形状值是：rect (*top*, *right*, *bottom*, *left*) |
| auto    | 默认值。不应用任何剪裁。                                     |
| inherit | 规定应该从父元素继承 clip 属性的值。                         |

由于clip中得所有偏移都是距左上角得偏移，所以不允许有百分数，实际上不可能创造一个“中心”裁剪区域，唯一的方法就是通过设置元素本身的高度和宽度进行定义。

元素的可见性。除了裁剪和溢出，还可以控制整个元素的可见性。

| 值       | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| visible  | 默认值。元素是可见的。                                       |
| hidden   | 元素是不可见的。元素还是会影响文档的布局。                   |
| collapse | 当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局。被行或列占据的空间会留给其他内容使用。如果此值被用在其他的元素上，会呈现为 "hidden"。 |
| inherit  | 规定应该从父元素继承 visibility 属性的值。                   |

绝对定位。元素绝对定位时，会从文档流中完全删除，然后相对于其包含块定位，其边界根据偏移属性放置，定位元素不会流入其他元素的内容。这说明，绝对定位元素可能覆盖其他元素，或者被其他元素覆盖。

绝对定位元素的包含块是最近的position值不为static的祖先元素，一般会选择一个元素作为绝对定位元素的包含块，将其position指定为relative而且没有偏移。同时，元素绝对定位时，还会为其后代元素建立一个包含块。如果文档可滚动，定位元素会随着它滚动，只要绝对定位元素不是固定定位元素的后代。情况都是如此，其原因是元素最终会相对于正常流得某一部分定位。

绝对定位元素的放置和大小。规范可以将绝对元素得“放置”和“大小”联系起来，如果包含块更高，name h1也会更高，如果包含块更窄，h1也会跟着更窄，如果向h1增加外边距或内边距，这会对h1的高度和宽度计算值有进一步的影响。

```css
#masthead h1 {
    position: absolute; 
    top: 1em; left: 1em; 
    right: 25%; bottom: 10px;
    margin: 0; padding: 0;
    background: silver;
}  
```

自动边偏移。元素绝对定位时，如果除bottom外某个任意偏移属性设置为auto，会有一种特殊的行为。定位元素与其“静态”位置一致，即定位元素的某端要相对于其未定位前本来的某端位置对齐。

非替换元素的放置和大小。一般地，元素的大小和位置取决于其包含块。各个属性（width，right，padding-left等）的值也会有一些影响，不过最主要的还是起包含块。

- 如果left、width和right都设置为auto，左边界置于其静态位置，元素的width设置为内容区宽度恰好只能包含其内容，从元素右边界到包含块右边界之间余下的距离则是right的计算值。
- 如果左右外边距都设置为auto，而left、width和right不是auto，此时左右外边距会设置为相等的值，实际上让元素居中。这与正常流中得auto外边距居中行为基本上是一样的。假设外边距不为auto，在这种情况下，用户代理会忽略right得值，使差额得到补充。假设某个外边距保持为auto，则会改变这个外边框。
- 如果上下外边距都设置为auto，可以得到垂直居中的效果。另外，在水平布局中，如果值设置为auto，right或left都可以根据其静态位置放置，但在垂直布局汇总，只有top可以取静态位置，处于某种原因，bottom做不到。
- 如果一个绝对定位元素的大小在垂直方向上过度受限，将忽略bottom。

替换元素的放置和大小。非替换元素和替换元素的定位规则大不相同，这是因为替换元素固有的高度和宽度，因此其大小一般不会改变。

- 如果width设置为auto，width得实际使用值由元素内容的固有宽度决定。
- 在从左向右的语言中，如果left值为auto，要把auto替换为静态位置。
- 如果left或right仍未auto，也就是说，未在上一步中被替换，则将margin-left或margin-right得auto值替换为0.
- 如果此时margin-left和margin-right都还定义为auto，则把它们设置为相等的值，从而将元素在其包含块中居中。
- 在此之后，如果只剩下一个auto值，则将其修改为等于等式的余下部分。

Z轴上的放置。利用z-index，可以改变元素相互覆盖的顺序，这个属性的名字由坐标系统得来。在这个坐标系中，有较高z-index值的元素比z-index值较低的元素离读者更近。一旦为一个元素指定了z-index值（不是auto），该元素就会建立自己的局部叠放上下文，这意味着，元素的所有后代相对于该祖先元素都有自己的叠放顺序，这非常类似于元素建立新包含块的方式。如果将元素设置为`z-index: auto`，可以将其处理为`z-index: 0` 。

固定定位。固定定位与绝对定位很类似，只不过固定元素的包含块是视窗。固定定位时，元素会完全从文档流中去除，不会有相对于文档中任何部分的位置。通过设置属性，可以将其固定在视窗中，并保持不动，而不论文档如何滚动，这样的缺点就是文档的其余部分会被固定元素覆盖。因此，可能应当把其余内容包含在其的自己的div中，并设置为余下的非固定位置。

相对定位。采用相对定位机制，将通过使用偏移属性移动定位元素。当元素相对定位时，它会从其正常位置移走，但原来所占的空间并不会因此消失。当然，还可以移动一个相对定位元素，让它覆盖其他内容。如果相对定位一个元素，它会立即为其所有子元素建立一个新的包含块，这个包含块对应于该元素原本所在的位置。如果一个相对定位元素过度受限，一个值会重置为另一个值的相反数。

10.3 小结

# 第11章 表布局

表格式化
表单元格边距
表大小
小结

# 第12章 列表与生成内容

列表
生成内容
小结

# 第13章 用户界面样式

系统字体和颜色
光标
轮廓
小结

# 第14章 非屏幕媒体

设计特定于媒体的样式表
分页媒体
声音样式
小结
附录A属性参考
附录B选择器、伪类和伪元素参考
附录C示例HTML4样式表